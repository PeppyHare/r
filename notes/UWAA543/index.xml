<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Computational CFD on My Notes</title><link>https://peppyhare.github.io/r/notes/UWAA543/</link><description>Recent content in Computational CFD on My Notes</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://peppyhare.github.io/r/notes/UWAA543/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction to Computational CFD</title><link>https://peppyhare.github.io/r/notes/UWAA543/ch20-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://peppyhare.github.io/r/notes/UWAA543/ch20-1/</guid><description>20.1 Introduction to Computational CFD # What is computational fluid dynamics? Put simply, it&amp;rsquo;s the use of computers to obtain a numerical solution to the governing equations of fluid dynamics. As always, the numerical solution is an approximation to the real solution to the equations, but additionally those equations are themselves only an approximation of the real physics.
We will be interested in speeds much less than \( c \) (\( 3 \cdot 10^8 m/s) \) and distances much greater than the atomic radius \( \alpha_{bohr} = 5 \cdot 10^{-11} m \).</description></item><item><title>Governing Equations</title><link>https://peppyhare.github.io/r/notes/UWAA543/ch20-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://peppyhare.github.io/r/notes/UWAA543/ch20-2/</guid><description>Governing Equations # Continuity
\[\pdv{\rho}{t} &amp;#43; v \cdot \grad \rho = - \rho \grad \cdot v\] Momentum:
\[\rho \left( \pdv{v}{t} &amp;#43; v \cdot \grad v\right) &amp;#43; \grad p - \frac{1}{\mu_0} (\curl \vec B) \cross \vec B = \div \vec T \] \[\vec T = \text{ viscous stress tensor }\] \[\frac{1}{\mu_0} \curl \vec B = \vec j = \text{ current density }\] Magnetic Field
\[\pdv{B}{t} - \curl ( v \cross B) = - \curl \left[ \frac{\eta}{\mu_0} (\curl \vec B) \right]\] \[\eta = \text{ electrical resistivity }\] Energy:</description></item><item><title>Reduced Models</title><link>https://peppyhare.github.io/r/notes/UWAA543/ch20-3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://peppyhare.github.io/r/notes/UWAA543/ch20-3/</guid><description>20.3 Reduced Models # Further simplifications to the fluid models provide equations that are easier to solve. But we have to make sure that the reduced models (anything that&amp;rsquo;s not the full equation system) still capture the relevant physics of the problem.
Let&amp;rsquo;s assume the (2D) flow is
irrotational \( (\curl v = 0) \) isentropic steady-state This lets us apply potential flow theory. Since the flow is irrotational, the curl of the velocity field is zero, so we can define a potential</description></item><item><title>Equation Types</title><link>https://peppyhare.github.io/r/notes/UWAA543/ch20-4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://peppyhare.github.io/r/notes/UWAA543/ch20-4/</guid><description>Equation Types # PDE&amp;rsquo;s can be classified as elliptic, parabolic, or hyperbolic. The type of equation will suggest the choice of an appropriate algorithm.
The equation type can change for different flow parameters, or even for different regions within the same domain.
20.4.1 Scalar Equations # All of the scalar equations in fluid dynamics can be written in canonical form as the following 2nd order PDE.
\[a \phi_{xx} &amp;#43; b \phi_{xy} &amp;#43; c \phi_{yy} &amp;#43; d \phi_x &amp;#43; e \phi_y &amp;#43; f \phi = g\] where \( x, y \) are any two independent variables.</description></item><item><title>Panel Method</title><link>https://peppyhare.github.io/r/notes/UWAA543/ch20-5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://peppyhare.github.io/r/notes/UWAA543/ch20-5/</guid><description>20.5 Panel Method # Panel methods are a classical approach to solving flow problems that is still very useful today when finding solutions to even very complicated geometries. You represent a body as a series of panels.
A few definitions first: we say a source panel of strength \( \lambda \) (units m/s) is defined by:
\[\phi_p = \frac{1}{2 \pi} \int \lambda \ln (r) \dd s\] \[= \frac{1}{2 \pi} \int \lambda \ln \left( \sqrt{ (x_p - x)^2 &amp;#43; (y_p - y)^2}\right) \dd s\] \[\lambda = 2 u_\lambda\] Approximate a body as a polygon of N sides.</description></item><item><title>Finite Difference Algorithms</title><link>https://peppyhare.github.io/r/notes/UWAA543/ch21-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://peppyhare.github.io/r/notes/UWAA543/ch21-1/</guid><description>21.1 Finite Difference Algorithms # Definitions # By definition, Finite Differencing is a method to approximate partial differential equations which we cannot solve, into a system of algebraic equations which we can.
Notation to simplify our representations:
Superscripts: We use superscripts to denote steps in the time domain \( t^n = n \Delta t \). Here \( n = [0, N] \) is the step index and \( \Delta t \) is the time-step \( T/N \) Subscripts: \( x_j = j \Delta x \).</description></item><item><title>Explicit Finite Difference Algorithms</title><link>https://peppyhare.github.io/r/notes/UWAA543/ch21-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://peppyhare.github.io/r/notes/UWAA543/ch21-2/</guid><description>Explicit Finite Difference Algorithms # Explicit Algorithms # Forward Euler (FTFS) # n+1 --------|--------*--------|-------- n --------|--------*--------*-------- j-1 j j+1 \[u_j ^{n&amp;#43;1} = u_j ^n - \frac{a \Delta t}{\Delta x} (u_{j&amp;#43;1} ^n - u_j ^n)\] The accuracy is \( O(\Delta t, \Delta x) \). Previously we saw that the von Neumann stability analysis shows
\[a &amp;gt; 0 \rightarrow \text{ Unconditionally unstable}\] \[a &amp;lt; 0 \rightarrow \left| \frac{ a \Delta t}{\Delta x} \leq 1 \right| \quad \text{ for stability }\] Forward-Time Centered Space (FTCS) # \[u_j ^{n&amp;#43;1} = u_j ^n - \frac{a \Delta t}{\Delta x} \frac{u_{j&amp;#43;1} ^n - u_{j-1} ^n}{2}\] We also found that this is unconditionally unstable.</description></item><item><title>Finite Difference and Finite Volume Methods</title><link>https://peppyhare.github.io/r/notes/UWAA543/ch21-3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://peppyhare.github.io/r/notes/UWAA543/ch21-3/</guid><description>Finite Difference and Finite Volume Methods # Finite volume methods can easily handle arbitrary geometries. You can use arbitrarily shaped cells, irregular meshes, and even unstructured meshes. With an irregular mesh, the cell shapes can distort. In an unstructured mesh, the cell shape can even change. Why would you ever want that, you may ask? Consider a circular shape in the middle of our domain. We&amp;rsquo;ll have a pretty hard time fitting a regular or even irregular mesh to a circle.</description></item><item><title>Implicit Algorithms</title><link>https://peppyhare.github.io/r/notes/UWAA543/ch21-4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://peppyhare.github.io/r/notes/UWAA543/ch21-4/</guid><description>Implicit Algorithms # Stability conditions are often related to the CFL number, and stability analysis of explicit algorithms usually require us to set a limit to small CFL
\[\left| \frac{a \Delta x}{\Delta t} \right| \leq 1\] For a given grid, this effectively sets a limit on the time step. The time step can be no larger than the grid spacing divided by the propagation constant \( \Delta t \leq \Delta x / |a| \).</description></item><item><title>Numerical Boundary Conditions</title><link>https://peppyhare.github.io/r/notes/UWAA543/ch21-5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://peppyhare.github.io/r/notes/UWAA543/ch21-5/</guid><description>Numerical Boundary Conditions # The linear advection equation is
\[\pdv{u}{t} &amp;#43; a \pdv{u}{x} = 0\] For it to be a well-posed mathematical problem, you also need the Cauchy data (boundary and initial conditions). From the order of the differential operators, we know that we need one boundary condition (constraint on \( u(x_b) \) for all \( t \) ) and one initial condition (constraint on \( u(x) \) at \( t = 0 \)).</description></item></channel></rss>