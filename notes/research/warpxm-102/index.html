<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content=" \[\] What Happens When You Press Go?# Following the sequence of events that take place in a WARPXM simulation by stepping through in the debugger has helped me to understand the code structure and concepts. I would highly recommend going through the process at least once. I have tried to explain what happens in plain English in the hopes that it will help me (and maybe someone else) to better understand how things are structured and what to expect when working with WARPXM.
"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://peppyhare.github.io/r/notes/research/warpxm-102/"><meta property="og:site_name" content="My Notes"><meta property="og:title" content="WARPXM 102 - Code Structure"><meta property="og:description" content="\[\] What Happens When You Press Go?# Following the sequence of events that take place in a WARPXM simulation by stepping through in the debugger has helped me to understand the code structure and concepts. I would highly recommend going through the process at least once. I have tried to explain what happens in plain English in the hopes that it will help me (and maybe someone else) to better understand how things are structured and what to expect when working with WARPXM."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta property="article:modified_time" content="2026-01-30T12:21:17-08:00"><meta itemprop=name content="WARPXM 102 - Code Structure"><meta itemprop=description content="\[\] What Happens When You Press Go?# Following the sequence of events that take place in a WARPXM simulation by stepping through in the debugger has helped me to understand the code structure and concepts. I would highly recommend going through the process at least once. I have tried to explain what happens in plain English in the hopes that it will help me (and maybe someone else) to better understand how things are structured and what to expect when working with WARPXM."><meta itemprop=dateModified content="2026-01-30T12:21:17-08:00"><meta itemprop=wordCount content="4133"><title>WARPXM 102 - Code Structure | My Notes</title><link rel=icon href=/r/favicon.png><link rel=manifest href=/r/manifest.json><link rel=canonical href=https://peppyhare.github.io/r/notes/research/warpxm-102/><link rel=stylesheet href=/r/book.min.ba28f313a83446a28b57b814dee23b24f1f381a68a01c0464ef5577ab2f61ded.css integrity="sha256-uijzE6g0RqKLV7gU3uI7JPHzgaaKAcBGTvVXerL2He0=" crossorigin=anonymous><script defer src=/r/fuse.min.js></script><script defer src=/r/en.search.min.5d518feacf9f5e7b2a68534d5167781d8074aeb7747c131300edeaf112598b79.js integrity="sha256-XVGP6s+fXnsqaFNNUWd4HYB0rrd0fBMTAO3q8RJZi3k=" crossorigin=anonymous></script><script defer src=/r/sw.min.9e3a83f0b071ebe0141a16a33db93faadb2bdf712473a218febeed35ed243c08.js integrity="sha256-njqD8LBx6+AUGhajPbk/qtsr33Ekc6IY/r7tNe0kPAg=" crossorigin=anonymous></script><link rel=preload href=/r/katex/fonts/KaTeX_Main-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/r/katex/fonts/KaTeX_Main-Bold.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/r/katex/fonts/KaTeX_Main-Italic.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/r/katex/fonts/KaTeX_Math-Italic.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/r/katex/fonts/KaTeX_Size2-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/r/katex/fonts/KaTeX_Size3-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/r/fonts/roboto-v27-latin-regular.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/r/fonts/roboto-v27-latin-700.woff2 as=font type=font/woff2 crossorigin=anonymous></head><body dir=ltr class="book-kind-page book-type-notes"><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/r/><span>My Notes</span></a></h2><div class="book-search hidden"><input id=book-search-input type=text placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class=flex><a role=button><img src=/r/icons/translate.svg class=book-icon alt=Languages>
English
</a><img src=/r/icons/chevron-right.svg class=book-icon alt=Expand></label><ul></ul></li></ul><ul><li class=book-section-flat><a>Notes</a><ul><li class=book-section-flat><input type=checkbox id=section-f04c181c9b16a37431fe06303d58b7a0 class=toggle>
<label for=section-f04c181c9b16a37431fe06303d58b7a0 class=flex><a href=/r/notes/UWAA545/>Computational Methods For Plasmas</a>
<img src=/r/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/r/notes/UWAA545/01-syllabus/>Syllabus</a></li><li><a href=/r/notes/UWAA545/02-plasma-models/>Plasma Models</a></li><li><a href=/r/notes/UWAA545/03-pic-method/>Particle in Cell Model</a></li><li><a href=/r/notes/UWAA545/04-pic-example/>PIC - Example Implementation</a></li><li><a href=/r/notes/UWAA545/05-electrodynamic-pic/>Multidimensional Electrodynamic PIC</a></li><li><a href=/r/notes/UWAA545/06-fluid-models/>Fluid Models for Plasmas</a></li><li><a href=/r/notes/UWAA545/07-finite-difference-models/>Finite Difference Methods for MHD</a></li><li><a href=/r/notes/UWAA545/08-mhd-equilibrium/>MHD Equilibrium Calculations</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-b6bdf3598cf4214623cd2f8ff7b6e0f2 class=toggle>
<label for=section-b6bdf3598cf4214623cd2f8ff7b6e0f2 class=flex><a href=/r/notes/UWAA560/>Plasma Diagnostics</a>
<img src=/r/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/r/notes/UWAA560/01-syllabus/>Syllabus</a></li><li><a href=/r/notes/UWAA560/02-diagnostic-considerations/>General Diagnostic Considerations</a></li><li><a href=/r/notes/UWAA560/03-magnetic-field-diagnostics/>Magnetic Field Diagnostics</a></li><li><a href=/r/notes/UWAA560/04-electrostatic-diagnostics/>Electrostatic Diagnostics</a></li><li><a href=/r/notes/UWAA560/05-index-of-refraction-measurements/>Index of Refraction Measurements</a></li><li><a href=/r/notes/UWAA560/06-spectroscopic-measurements/>Spectroscopic Measurements</a></li><li><a href=/r/notes/UWAA560/90-student-lectures/>Student Lectures</a></li><li><a href=/r/notes/UWAA560/91-zeeman-spectroscopy/>My class lecture</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-5b051410be8cdb0f46ad32fc2ad5a20d class=toggle>
<label for=section-5b051410be8cdb0f46ad32fc2ad5a20d class=flex><a href=/r/notes/UWAA558/>MHD Theory</a>
<img src=/r/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/r/notes/UWAA558/01-syllabus/>Syllabus</a></li><li><a href=/r/notes/UWAA558/02-plasma-models/>Plasma Models</a></li><li><a href=/r/notes/UWAA558/03-plasma-fluid-model/>Plasma Fluid Model</a></li><li><a href=/r/notes/UWAA558/04-two-fluid-plasma-model/>Two-Fluid Plasma Model</a></li><li><a href=/r/notes/UWAA558/05-mhd-model/>Magnetohydrodynamic (MHD) Model</a></li><li><a href=/r/notes/UWAA558/06-boundary-conditions/>Boundary Conditions</a></li><li><a href=/r/notes/UWAA558/07-equilibrium-for-fusion/>Equilibrium for Fusion</a></li><li><a href=/r/notes/UWAA558/08-1d-equilibria/>1-D Equilibria</a></li><li><a href=/r/notes/UWAA558/09-2d-equilibria/>2D Equilibria</a></li><li><a href=/r/notes/UWAA558/10-equilibrium-of-3d-configurations/>Equilibrium of 3D Configurations</a></li><li><a href=/r/notes/UWAA558/11-mhd-stability/>MHD Stability</a></li><li><a href=/r/notes/UWAA558/formulary/>Formulary</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-c3201a1057283cb12ab09a42fe89bfb2 class=toggle checked>
<label for=section-c3201a1057283cb12ab09a42fe89bfb2 class=flex><a href=/r/notes/research/>Research Notes</a>
<img src=/r/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/r/notes/research/apollo/>Apollo dynamic tuning framework for RAJA</a></li><li><a href=/r/notes/research/dgh-datta/>Electrodynamic Dory-Guest-Harris Instability</a></li><li><a href=/r/notes/research/install-tricks/>Installation tricks</a></li><li><a href=/r/notes/research/valgrind/>Valgrind</a></li><li><a href=/r/notes/research/warpxm-101/>WARPXM 101 - Getting Started</a></li><li><a href=/r/notes/research/warpxm-102/ class=active>WARPXM 102 - Code Structure</a></li><li><a href=/r/notes/research/warpxm-201/>WARPXM 201 - Unstructured Geometry</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-e5101c35c8277102365bd86ab3e99a0d class=toggle>
<label for=section-e5101c35c8277102365bd86ab3e99a0d class=flex><a href=/r/notes/UWAMATH567/>Applied Complex Analysis</a>
<img src=/r/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/r/notes/UWAMATH567/01-overview/>Overview</a></li><li><a href=/r/notes/UWAMATH567/02-complex-numbers/>Complex Numbers</a></li><li><a href=/r/notes/UWAMATH567/03-analytic-functions/>Analytic Functions and Integration</a></li><li><a href=/r/notes/UWAMATH567/04-series/>Sequences, series, and singularities</a></li><li><a href=/r/notes/UWAMATH567/05-residue-calculus/>Residue calculus and applications of contour integration</a></li><li><a href=/r/notes/UWAMATH567/06-real-integrals/>Real Integrals</a></li><li><a href=/r/notes/UWAMATH567/07-integrals-of-multivalued-functions/>Integrals of Multivalued Functions</a></li><li><a href=/r/notes/UWAMATH567/08-fourier-transform/>Fourier Transforms and Laplace Transforms</a></li><li><a href=/r/notes/UWAMATH567/09-conformal-mapping/>Conformal Mappings</a></li><li><a href=/r/notes/UWAMATH567/10-fluid-flow/>Fluid Flow</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-34991d35561e8d266d64d5d323e97c7a class=toggle>
<label for=section-34991d35561e8d266d64d5d323e97c7a class=flex><a href=/r/notes/UWAA557/>Physics of Fusion Plasmas</a>
<img src=/r/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/r/notes/UWAA557/ch10-0/>Rules of thumb</a></li><li><a href=/r/notes/UWAA557/ch10-1/>Statistical Mechanics</a></li><li><a href=/r/notes/UWAA557/ch10-2/>Review of E&amp;M</a></li><li><a href=/r/notes/UWAA557/ch10-3/>Lagrange Multipliers</a></li><li><a href=/r/notes/UWAA557/ch11-1/>Wall-supported Plasma</a></li><li><a href=/r/notes/UWAA557/ch11-2/>Collisions</a></li><li><a href=/r/notes/UWAA557/ch11-3/>Oscillations</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-7c7b4e4d4494a744744faedd969cb670 class=toggle>
<label for=section-7c7b4e4d4494a744744faedd969cb670 class=flex><a href=/r/notes/UWAA543/>Computational CFD</a>
<img src=/r/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/r/notes/UWAA543/ch20-1/>Introduction to Computational CFD</a></li><li><a href=/r/notes/UWAA543/ch20-2/>Governing Equations</a></li><li><a href=/r/notes/UWAA543/ch20-3/>Reduced Models</a></li><li><a href=/r/notes/UWAA543/ch20-4/>Equation Types</a></li><li><a href=/r/notes/UWAA543/ch20-5/>Panel Method</a></li><li><a href=/r/notes/UWAA543/ch21-1/>Finite Difference Algorithms</a></li><li><a href=/r/notes/UWAA543/ch21-2/>Explicit Finite Difference Algorithms</a></li><li><a href=/r/notes/UWAA543/ch21-3/>Finite Difference and Finite Volume Methods</a></li><li><a href=/r/notes/UWAA543/ch21-4/>Implicit Algorithms</a></li><li><a href=/r/notes/UWAA543/ch21-5/>Numerical Boundary Conditions</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-e5f141895443fc824f58730f7904d483 class=toggle>
<label for=section-e5f141895443fc824f58730f7904d483 class=flex><a href=/r/notes/UWAA556/>Plasma Waves</a>
<img src=/r/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/r/notes/UWAA556/ch01-1/>Mathematical review</a></li><li><a href=/r/notes/UWAA556/ch02-1/>Plasma Waves in General Dielectric Media</a></li><li><a href=/r/notes/UWAA556/ch02-2/>Wave Properties in Cold Unmagnetized Plasma</a></li><li><a href=/r/notes/UWAA556/ch02-3/>Cold Magnetized Plasma Dispersion Relation</a></li><li><a href=/r/notes/UWAA556/ch02-4/>The CMA Diagram</a></li><li><a href=/r/notes/UWAA556/ch03-1/>Introduction to Kinetic Theory</a></li><li><a href=/r/notes/UWAA556/ch03-2/>Landau Damping</a></li><li><a href=/r/notes/UWAA556/ch03-3/>Waves in Hot Magnetized Plasma</a></li><li><a href=/r/notes/UWAA556/ch04-1/>Fluid stuff</a></li><li><a href=/r/notes/UWAA556/ch04-2/>Quasi-Linear Theory</a></li><li><a href=/r/notes/UWAA556/ch05-1/>Diffusion and Resistivity</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-3a2759a8b11b3422da800ed19897932a class=toggle>
<label for=section-3a2759a8b11b3422da800ed19897932a class=flex><a href=/r/notes/problems/>Worked Problems</a>
<img src=/r/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/r/notes/problems/gurnett/ch02/>Characteristic Parameters of a Plasma</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-05ac7760b68f0e0530d0e609833f6902 class=toggle>
<label for=section-05ac7760b68f0e0530d0e609833f6902 class=flex><a role=button>Scratch</a>
<img src=/r/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/r/notes/scratch/colors/>Adding Color</a></li><li><a href=/r/notes/scratch/crews2018/>Crews (2018)</a></li><li><a href=/r/notes/scratch/datta2021/>Datta (2021)</a></li><li><a href=/r/notes/scratch/drawing/>Drawing Diagrams</a></li><li><a href=/r/notes/scratch/goedbloed/>Goedbloed (2019)</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-c8688d5789736c2ae128963cf705a441 class=toggle>
<label for=section-c8688d5789736c2ae128963cf705a441 class=flex><a href=/r/notes/griffiths/>Griffiths Introduction to Electrodynamics</a>
<img src=/r/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/r/notes/griffiths/ch1-1/>(1.1) Vector Algebra</a></li><li><a href=/r/notes/griffiths/ch1-2/>(1.2) Differential Calculus</a></li><li><a href=/r/notes/griffiths/ch1-3/>(1.3) Integral Calculus</a></li><li><a href=/r/notes/griffiths/ch1-4/>(1.4) Curvilinear Coordinates</a></li><li><a href=/r/notes/griffiths/ch1-5/>(1.5) The Dirac Delta Function</a></li><li><a href=/r/notes/griffiths/ch1-6/>(1.6) The Theory of Vector Fields</a></li><li><a href=/r/notes/griffiths/ch2-1/>(2.1) The Electric Field</a></li><li><a href=/r/notes/griffiths/ch2-2/>(2.2) Divergence and Curl of Electrostatic Fields</a></li><li><a href=/r/notes/griffiths/ch2-3/>(2.3) Electric Potential</a></li><li><a href=/r/notes/griffiths/ch2-4/>(2.4) Work and Energy in Electrostatics</a></li><li><a href=/r/notes/griffiths/ch2-5/>(2.5) Conductors</a></li><li><a href=/r/notes/griffiths/ch3-1/>(3.1) Laplace's Equation</a></li><li><a href=/r/notes/griffiths/ch3-2/>(3.2) The Method of Images</a></li><li><a href=/r/notes/griffiths/ch3-3/>(3.3) Separation of Variables</a></li><li><a href=/r/notes/griffiths/ch3-4/>(3.4) Multipole Expansion</a></li><li><a href=/r/notes/griffiths/ch4-1/>(4.1) Polarization</a></li><li><a href=/r/notes/griffiths/ch4-2/>(4.2) The Field of a Polarized Object</a></li><li><a href=/r/notes/griffiths/ch4-3/>(4.3) The Electric Displacement</a></li><li><a href=/r/notes/griffiths/ch4-4/>(4.4) The Linear Dielectrics</a></li><li><a href=/r/notes/griffiths/ch5-1/>(5.1) The Lorentz Force Law</a></li><li><a href=/r/notes/griffiths/ch5-2/>(5.2) The Biot-Savart Law</a></li><li><a href=/r/notes/griffiths/ch5-3/>(5.3) The Divergence and Curl of B</a></li><li><a href=/r/notes/griffiths/ch5-4/>(5.4) Magnetic Vector Potential</a></li><li><a href=/r/notes/griffiths/ch6-1/>(6.1) Magnetization</a></li><li><a href=/r/notes/griffiths/ch6-2/>(6.2) The Field of a Magnetized Object</a></li><li><a href=/r/notes/griffiths/ch6-3/>(6.3) The Auxiliary Field H</a></li><li><a href=/r/notes/griffiths/ch6-4/>(6.4) Linear and Nonlinear Media</a></li><li><a href=/r/notes/griffiths/ch7-1/>(7.1) Electromotive Force</a></li><li><a href=/r/notes/griffiths/ch7-2/>(7.2) Electromagnetic Induction</a></li><li><a href=/r/notes/griffiths/ch7-3/>(7.3) Maxwell's Equations</a></li><li><a href=/r/notes/griffiths/ch8-0/>(8.0) Phys 544 Introduction</a></li><li><a href=/r/notes/griffiths/ch8-1/>(8.1) Charge and Energy</a></li><li><a href=/r/notes/griffiths/ch8-2/>(8.2) Momentum</a></li><li><a href=/r/notes/griffiths/ch9-1/>(9.1) Electromagnetic Waves in One Dimension</a></li><li><a href=/r/notes/griffiths/ch9-2/>(9.2) Wave Equation for E and B</a></li><li><a href=/r/notes/griffiths/ch9-3/>(9.3) Electromagnetic Waves in Matter</a></li><li><a href=/r/notes/griffiths/ch9-4/>(9.4) Electromagnetic Waves in Conductors</a></li><li><a href=/r/notes/griffiths/ch9-5/>(9.5) Guided Waves</a></li><li><a href=/r/notes/griffiths/ch10-1/>(10.1) Scalar and Vector Potentials</a></li><li><a href=/r/notes/griffiths/ch10-2/>(10.2) Retarded Potentials</a></li><li><a href=/r/notes/griffiths/ch10-3/>(10.3) Point Charges</a></li><li><a href=/r/notes/griffiths/ch11-1/>(11.1) Dipole Radiation</a></li><li><a href=/r/notes/griffiths/problems-ch3/>Solved Problems Ch3</a></li><li><a href=/r/notes/griffiths/problems-ch5/>Solved Problems Ch5</a></li><li><a href=/r/notes/griffiths/problems-ch7/>Solved Problems Ch7</a></li><li><a href=/r/notes/griffiths/problems-ch9/>Solved Problems Ch9</a></li></ul></li></ul></li></ul><ul class=book-menu-hugo><li><a href=https://github.com/Peppyhare/r target=_blank rel=noopener>Github</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Hugo Themes</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class="book-header hidden"><div class="flex align-center justify-between"><label for=menu-control><img src=/r/icons/menu.svg class=book-icon alt=Menu></label><h3>WARPXM 102 - Code Structure</h3><label for=toc-control><img src=/r/icons/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class=hidden><nav id=TableOfContents><ul><li><a href=#what-happens-when-you-press-go>What Happens When You Press Go?</a><ul><li><a href=#entrypoint>Entrypoint</a></li><li><a href=#setup>Setup</a><ul><li><a href=#domain-setup>Domain Setup</a></li><li><a href=#variable-setup>Variable Setup</a></li><li><a href=#host-action-initialization>Host Action Initialization</a></li></ul></li><li><a href=#solve>Solve</a><ul><li><a href=#pre-solve-actions>Pre-solve Actions</a></li><li><a href=#main-loop>Main Loop</a></li><li><a href=#class-diagrams>Class diagrams</a></li></ul></li><li><a href=#lets-try-to-go-through-the-same-exercise-but-for-the-ndg_kinetic-solver>Let&rsquo;s try to go through the same exercise, but for the ndg_kinetic solver</a></li><li><a href=#setup-1>Setup</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><link rel=stylesheet href=/r/katex/katex.min.css><script defer src=/r/katex/katex.min.js></script><script defer src=/r/katex/auto-render.min.js onload=loadKatex()></script><script>function loadKatex(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}],throwOnError:!1,trust:e=>["\\htmlId","\\href"].includes(e.command),macros:{"\\lcm":"\\mathop{\\mathrm{lcm}}","\\sen":"\\text{sen}\\,","\\dd":"\\mathop{\\mathrm{d} #1}","\\abs":"\\lvert #1 \\rvert","\\dd":"\\text{d}","\\cross":"\\times","\\pdv":"\\frac{\\partial #1}{\\partial #2}","\\curl":`\\nabla \\cross #1`,"\\vu":"\\mathbf{\\hat{#1}}","\\vdot":"\\dot","\\div":`\\nabla \\cdot #1`,"\\grad":`\\nabla`,"\\dv":"\\frac{d\\,#1}{d\\,#2}","\\gr":"\\gamma","\\vec":"\\mathbf{#1}","\\tagl":"\\tag{#1}","\\eqref":"(#1)","\\laplacian":`\\mathbf{\\nabla ^2}`,"\\label":"{}","\\negadelta":`\\nabla`,"\\eqref":"\\href{###1}{(\\text{#1})}","\\ref":"\\href{###1}{\\text{#1}}","\\label":"\\htmlId{#1}{}"}})}</script><span>\[\]</span><h1 id=what-happens-when-you-press-go>What Happens When You Press Go?<a class=anchor href=#what-happens-when-you-press-go>#</a></h1><p>Following the sequence of events that take place in a WARPXM simulation by stepping through in the debugger has helped me to understand the code structure and concepts. I would highly recommend going through the process at least once. I have tried to explain what happens in plain English in the hopes that it will help me (and maybe someone else) to better understand how things are structured and what to expect when working with WARPXM.</p><p>There are some code listings (as they appear in the WARPXM code base) included for context that can be expanded by clicking on them.</p><h2 id=entrypoint>Entrypoint<a class=anchor href=#entrypoint>#</a></h2><details><summary><code>warpxm.cc: int main(int argc, char** argv)</code></summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span><span style=color:#f92672>**</span> argv)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>warpxm_init(argc, argv)) { exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>); }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// run top level warpxm main
</span></span></span><span style=display:flex><span>    res <span style=color:#f92672>=</span> warpxm_main(argc, argv);
</span></span><span style=display:flex><span>    warpxm_finalize();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></details><p>The entrypoint for <code>warpxm</code> is simple, there are just three calls: <code>warpxm_init()</code>, <code>warpxm_main()</code>, and <code>warpxm_finalize()</code>. We don&rsquo;t need to pay much attention to <code>warpxm_init</code>, since it just initializes the MPI and PETSc frameworks. MPI is the message-passing framework that allows for massive parallelization. PETSc is a toolkit that <em>can</em> be used for a wide variety of numerical techniques, but we&rsquo;re currently only using it for parsing command-line options (and handling the installation of mutually compatible versions of various dependencies at install time).</p><p><code>warpxm_main</code> is similarly high level:</p><details><summary><code>warpxm.cc: int warpxm_main(int argc, char** argv)</code></summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>warpxm_main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span><span style=color:#f92672>**</span> argv)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// create new WARPXM simulation using the command line args
</span></span></span><span style=display:flex><span>    WmSimulation sim;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Parse the input command
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> res <span style=color:#f92672>=</span> sim.parseCmdLine();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (res) { <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Read in the input file
</span></span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>ifstream inp(sim.getInpFileName().c_str());
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... error checking ...
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Convert input file to a string
</span></span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string inputStr((std<span style=color:#f92672>::</span>istreambuf_iterator<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span>(inp)),
</span></span><span style=display:flex><span>                         std<span style=color:#f92672>::</span>istreambuf_iterator<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>    inp.seekg(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Store the input file in the simulation
</span></span></span><span style=display:flex><span>    sim.setInputFileText(inputStr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// create cryptset for simulation
</span></span></span><span style=display:flex><span>    WxCryptSet inputSet(inp);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Step one - setup the simulation
</span></span></span><span style=display:flex><span>    sim.setup(inputSet);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Step two - run the simulation
</span></span></span><span style=display:flex><span>    sim.simulate();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Step three - drink to your success
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></details><ul><li>Initialize our <code>WmSimulation</code> object. Nothing much happens when we init this other than creating a message-passing client (<code>WxMpiMsg</code>) and HDF5 i/o client (<code>WxHdf5Io</code>) that will be used to read/write data.</li><li>Parse the command-line options, simply reading the values of command-line flags.<ul><li><code>-input-file</code>/<code>-i</code> populates <code>inpFileName</code> with the input file contents, for parsing</li><li><code>-run-name</code>/<code>-n</code> populates <code>sim.runName</code></li><li><code>-restart-from-frame</code>/<code>-f</code> or <code>-restart-auto</code>/<code>-r</code> will populate <code>sim.restartFrame</code></li><li>If <code>-debug</code> was passed, the process waits for a debugger like <code>gdb</code> or <code>lldb</code> to attach to the process and allow things to continue.</li></ul></li><li>Turn the input file into a proper <code>WxCryptSet</code>, which is an immutable, nested map of name-value pairs for which each name is a string and each value is a native-type object, array of native objects, or another nested <code>WxCrypt</code>. I like to think about <code>WxCryptSet</code> as a thread-safe place to look up values which are global across the whole sim and which do not ever change, similar to the <code>Context</code> <a href=https://docs.python.org/3/library/multiprocessing.html#multiprocessing-managers>objects used in Python&rsquo;s multiprocessing module</a>.<ul><li>This step involves parsing the full text of the input file, as described in <a href=https://faculty.washington.edu/shumlak/WARPX/html/warpxm_input.html>https://faculty.washington.edu/shumlak/WARPX/html/warpxm_input.html</a></li></ul></li><li>Then, we do <code>sim.setup</code> and <code>sim.simulate</code> which cover the entire simulation</li></ul><h2 id=setup>Setup<a class=anchor href=#setup>#</a></h2><details><summary><code>wmsimulation.cc: void WmSimulation::setup(const WxCryptSet& wxc)</code></summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> WmSimulation<span style=color:#f92672>::</span>setup(<span style=color:#66d9ef>const</span> WxCryptSet<span style=color:#f92672>&amp;</span> wxc)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// determine run name
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (wxc.has(<span style=color:#e6db74>&#34;RunName&#34;</span>))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>string possibleRunName <span style=color:#f92672>=</span> wxc.get<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span>(<span style=color:#e6db74>&#34;RunName&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (possibleRunName[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;/&#39;</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// This is a filename from root
</span></span></span><span style=display:flex><span>            runName <span style=color:#f92672>=</span> possibleRunName;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// This is a filename in the current directory
</span></span></span><span style=display:flex><span>            size_t trnc <span style=color:#f92672>=</span> inpFileName.find_last_of(<span style=color:#e6db74>&#34;/&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (trnc <span style=color:#f92672>!=</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>::</span>npos)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                runName <span style=color:#f92672>=</span> inpFileName.substr(<span style=color:#ae81ff>0</span>, trnc) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;/&#34;</span> <span style=color:#f92672>+</span> possibleRunName;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                runName <span style=color:#f92672>=</span> possibleRunName;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (runName <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        runName <span style=color:#f92672>=</span> stripName(inpFileName);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// create WarpX root logger
</span></span></span><span style=display:flex><span>    WxLogger<span style=color:#f92672>*</span> wr <span style=color:#f92672>=</span> WxLogger<span style=color:#f92672>::</span>get(<span style=color:#e6db74>&#34;warpx-root&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// set root logger&#39;s verbosity level
</span></span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string level;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (wxc.has(<span style=color:#e6db74>&#34;GlobalVerbosity&#34;</span>))
</span></span><span style=display:flex><span>        level <span style=color:#f92672>=</span> wxc.get<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span>(<span style=color:#e6db74>&#34;GlobalVerbosity&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        level <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;debug&#34;</span>;
</span></span><span style=display:flex><span>    wr<span style=color:#f92672>-&gt;</span>setLevel(level);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// add file handler to root logger
</span></span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>ostringstream fn;
</span></span><span style=display:flex><span>    fn <span style=color:#f92672>&lt;&lt;</span> runName <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;_&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>getMsg().rank() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;.log&#34;</span>;
</span></span><span style=display:flex><span>    WxLogRecordHandler<span style=color:#f92672>*</span> wrfhndl <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> WxFileHandler(fn.str());
</span></span><span style=display:flex><span>    wr<span style=color:#f92672>-&gt;</span>addHandler(wrfhndl);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// create WarpX console logger
</span></span></span><span style=display:flex><span>    WxLogger<span style=color:#f92672>*</span> wrc <span style=color:#f92672>=</span> WxLogger<span style=color:#f92672>::</span>get(<span style=color:#e6db74>&#34;warpx-root.console&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// set console logger&#39;s verbosity level
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (wxc.has(<span style=color:#e6db74>&#34;Verbosity&#34;</span>))
</span></span><span style=display:flex><span>        level <span style=color:#f92672>=</span> wxc.get<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span>(<span style=color:#e6db74>&#34;Verbosity&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        level <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;debug&#34;</span>;
</span></span><span style=display:flex><span>    wrc<span style=color:#f92672>-&gt;</span>setLevel(level);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// add stream handler to console
</span></span></span><span style=display:flex><span>    WxLogRecordHandler<span style=color:#f92672>*</span> wrshndl <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> WxStreamHandler();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>getMsg().rank() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#75715e>// add console stream only on rank 0
</span></span></span><span style=display:flex><span>        wrc<span style=color:#f92672>-&gt;</span>addHandler(wrshndl);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// get output streams from newly created loggers
</span></span></span><span style=display:flex><span>    WxLogStream debStrm <span style=color:#f92672>=</span> wrc<span style=color:#f92672>-&gt;</span>getDebugStream();
</span></span><span style=display:flex><span>    WxLogStream infoStrm <span style=color:#f92672>=</span> wrc<span style=color:#f92672>-&gt;</span>getInfoStream();
</span></span><span style=display:flex><span>    WxLogStream errStrm <span style=color:#f92672>=</span> wrc<span style=color:#f92672>-&gt;</span>getErrorStream();
</span></span><span style=display:flex><span>    WxLogStream wrnStrm <span style=color:#f92672>=</span> wrc<span style=color:#f92672>-&gt;</span>getWarningStream();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//////////////////////////////
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// now setup top level solver
</span></span></span><span style=display:flex><span>    debStrm <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Setting up WARPXM simulation...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string simName;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// name of simulation to run
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (wxc.has(<span style=color:#e6db74>&#34;Simulation&#34;</span>))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        simName <span style=color:#f92672>=</span> wxc.get<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span>(<span style=color:#e6db74>&#34;Simulation&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// no simulation specified, so throw exception
</span></span></span><span style=display:flex><span>        WxExcept <span style=color:#a6e22e>wxe</span>(<span style=color:#e6db74>&#34;No Simulation key found in &#34;</span>);
</span></span><span style=display:flex><span>        wxe <span style=color:#f92672>&lt;&lt;</span> inpFileName <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> wxe;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>wxc.hasSet(simName))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// solver not found
</span></span></span><span style=display:flex><span>        WxExcept <span style=color:#a6e22e>wxe</span>(<span style=color:#e6db74>&#34;ERROR: Solver set &#34;</span>);
</span></span><span style=display:flex><span>        wxe <span style=color:#f92672>&lt;&lt;</span> simName <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; not found&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> wxe;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// get hold of solver&#39;s cryptset
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> WxCryptSet<span style=color:#f92672>&amp;</span> solverCrypt <span style=color:#f92672>=</span> wxc.getSet(simName);
</span></span><span style=display:flex><span>    debStrm <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Simulation name is &#34;</span> <span style=color:#f92672>&lt;&lt;</span> simName <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// while the general class structure is setup to handle registration and WxCreator
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// process for getting new instances of WmSolverBase types
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// as is done elsewhere in the code for WmVariables, and WmHostActions, for example,
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// we have not implemented this functionality because
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// there has only ever been one class implementation, WmSolver.
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// To mimick the formatting at other levels of the crypt set, we at least check that
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// the Type and Kind fields match what they should be.
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (solverCrypt.has(<span style=color:#e6db74>&#34;Type&#34;</span>))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>string solverTypeStr <span style=color:#f92672>=</span> solverCrypt.get<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span>(<span style=color:#e6db74>&#34;Type&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (solverTypeStr <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;WmSolverBase&#34;</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            WxExcept <span style=color:#a6e22e>wxe</span>(<span style=color:#e6db74>&#34;Unrecognized Type field in input file for Simulation &#34;</span>);
</span></span><span style=display:flex><span>            wxe <span style=color:#f92672>&lt;&lt;</span> simName <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;.  Only &#39;WmSolverBase&#39; currently supported.&#34;</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> wxe;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#a6e22e>WxExcept</span>(<span style=color:#e6db74>&#34;Simulation &#39;Type&#39; field missing in input file.&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (solverCrypt.has(<span style=color:#e6db74>&#34;Kind&#34;</span>))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>string solverKindStr <span style=color:#f92672>=</span> solverCrypt.get<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span>(<span style=color:#e6db74>&#34;Kind&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (solverKindStr <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;WmSolver&#34;</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            WxExcept <span style=color:#a6e22e>wxe</span>(<span style=color:#e6db74>&#34;Unrecognized Kind field in input file for Simulation &#34;</span>);
</span></span><span style=display:flex><span>            wxe <span style=color:#f92672>&lt;&lt;</span> simName <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;. Only &#39;WmSolver&#39; currently supported.&#34;</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> wxe;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#a6e22e>WxExcept</span>(<span style=color:#e6db74>&#34;Simulation &#39;Kind&#39; field missing in input file.&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// create new solver
</span></span></span><span style=display:flex><span>    solver <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> WmSolver(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// set I/O for use in solver
</span></span></span><span style=display:flex><span>    solver<span style=color:#f92672>-&gt;</span>setIo(<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>getIo());
</span></span><span style=display:flex><span>    <span style=color:#75715e>// set msg for use in solver
</span></span></span><span style=display:flex><span>    solver<span style=color:#f92672>-&gt;</span>setMsg(<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>getMsg());
</span></span><span style=display:flex><span>    <span style=color:#75715e>// setup solver
</span></span></span><span style=display:flex><span>    solver<span style=color:#f92672>-&gt;</span>setup(solverCrypt);
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></details><p>A lot of things going on in <code>WmSimulation::setup</code>!</p><ul><li>Less important initialization: Ensure we have a <code>runName</code>, initialize the <code>WxLogger</code> loggers</li><li>Create a <code>WmSolver</code> and give it the same i/o and message clients as the <code>sim</code></li><li>Run <code>WmSolver.setup</code> with the <code>&lt;sim></code> node of the input file as input<ul><li>Sets the start and end times of the sim.</li><li>If the sim is being restarted (one of the restart command-line flags was passed), figure out the appropriate frame we should start at.</li><li>Set up the simulation domain</li><li>Create any variables defined in the input file</li><li>Initialize all host actions</li></ul></li></ul><h3 id=domain-setup>Domain Setup<a class=anchor href=#domain-setup>#</a></h3><ul><li>Create a <code>WmDomain</code> object and run <code>WmDomain.setup</code><ul><li>Figure out how many different MPI processes are relevant, based on the <code>NumPartitions</code> field in the input file</li><li>Create a <code>mesh</code> from the <code>&lt;mesh></code> node of the input file<ul><li>If the sim is being restarted, look for the appropriate mesh <code>.h5</code> file in the working directory, and error if not found</li><li>Generate the appropriate type of mesh. This is usually a block mesh (<code>block_mesh</code>) which just contains equally-spaced cells, but can also be an arbitrary mesh.</li><li>Write the generated mesh definition to a file, e.g. <code>block_mesh_abd3712ea51f965c.inp</code></li><li>Break the mesh up into <code>WmUnstructuredPatch</code> patches so that it can be distributed across however many MPI processes we have.</li><li>Generate the appropriate geometry for each patch. For any local patches (patches which should be managed by the current MPI process), we generate the full mesh geometry as a <code>WmUnstructuredGeometry</code>, which is the basic structure we use to represent the geometric nodes for the mesh. Once the mesh is generated, we dump the mesh for each patch as an h5 file (<code>restartMesh...</code>) so that we may restart the simulation at a later time without needing to re-generate the geometry.</li><li>We use DG basis elements to represent the mesh, so we also export the basis decomposition for the patch domain as an h5 file (<code>plotMesh...</code>), so that it is possible to reconstruct the physical geometry for later plotting and analysis</li></ul></li></ul></li></ul><h3 id=variable-setup>Variable Setup<a class=anchor href=#variable-setup>#</a></h3><ul><li>For each variable defined in the input file (everything of <code>Type = variable</code>) we initialize that variable setting its basis according the domain we computed above</li><li>For the hybrid kinetic solver, we additionally compute bases for the velocity space elements here.</li><li>Variables are not set to their initial values yet; that is done by a variable adjuster host action (<code>va_runner</code>) next</li></ul><h3 id=host-action-initialization>Host Action Initialization<a class=anchor href=#host-action-initialization>#</a></h3><ul><li>Each host action (<code>Type = WmHostAction|host_action|subsolver</code>) gets setup and inserted into the hostActions map. Different types of host action have different setup steps and effects. There are <a href=/r/img/research/warpxm/classdiagram-hostaction.png>a lot</a> of different types that directly extend <code>WmHostAction</code> in WARPXM, but the top-level ones relevant to most sims are:<ul><li><strong>Time Integrator</strong>: The time integrator that moves the state forward in time. This will almost always be the explicit Runge-Kutta temporal solver.</li><li><strong>Patch Processors</strong>: This coordinates patch processes across the domain. Patch processes are any process which can be evaluated locally within a single patch. For example, the spatial solver is a patch process which is called by the time integrator host action to compute \( \pdv{q}{t} \) (by implementing the nodal discontinuous Galerkin method). Variable adjusters which set/modify the value of variables across the domain are another common example, and are used to set initial conditions as we&rsquo;ll see later.</li><li><strong>Writers</strong>: Two types of writer: frame writers and diagnostic writers. A frame writer dumps the current variables to disk in HDF5 format each frame. The frame writer only needs to write the current data for the local patch, as opposed to diagnostic writers which are typically used to integrate variables across the global domain. Diagnostics can be <code>Probe</code>s (simply retrieve the current value of variables) or <code>WmIntegrator</code>s (integrate an expression over the domain or a subdomain). At pre-defined time intervals, the diagnostics writer evaluates each defined diagnostic and writes the result to a CSV file.</li><li><strong>Synchronizer</strong> When we require data that spans patches hosted on different MPI processes, an asynchronous process is required to manage the requesting and copying of that data.</li></ul></li></ul><h2 id=solve>Solve<a class=anchor href=#solve>#</a></h2><p>This is where the real work happens, so we need to pay extra attention here</p><details><summary><code>wmsolver.cc: void WmSolver::solve()</code></summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> WmSolver<span style=color:#f92672>::</span>solve()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    WxLogger<span style=color:#f92672>*</span> log <span style=color:#f92672>=</span> WxLogger<span style=color:#f92672>::</span>get(<span style=color:#e6db74>&#34;warpx-root.console&#34;</span>);
</span></span><span style=display:flex><span>    WxLogStream infStrm <span style=color:#f92672>=</span> log<span style=color:#f92672>-&gt;</span>getInfoStream();
</span></span><span style=display:flex><span>    WxLogStream debStrm <span style=color:#f92672>=</span> log<span style=color:#f92672>-&gt;</span>getDebugStream();
</span></span><span style=display:flex><span>    WxLogStream errStrm <span style=color:#f92672>=</span> log<span style=color:#f92672>-&gt;</span>getErrorStream();
</span></span><span style=display:flex><span>    presolve();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    real frame_time <span style=color:#f92672>=</span> (_tend <span style=color:#f92672>-</span> _tstart) <span style=color:#f92672>/</span> _nout;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> start_time <span style=color:#f92672>=</span> getCurrentTime();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> start_frame <span style=color:#f92672>=</span> getCurrentFrame();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.start(wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>ROOT_TIMING_SCOPE);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (size_t i <span style=color:#f92672>=</span> getCurrentFrame(); i <span style=color:#f92672>&lt;</span> _nout; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> frame_stop_time <span style=color:#f92672>=</span> start_time <span style=color:#f92672>+</span> (i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> start_frame) <span style=color:#f92672>*</span> frame_time;
</span></span><span style=display:flex><span>        infStrm <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Advancing solution starting at time &#34;</span> <span style=color:#f92672>&lt;&lt;</span> getCurrentTime() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; to &#34;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>&lt;&lt;</span> frame_stop_time <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;...</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Instantiate a new timer and most restrictive timestep constraint
</span></span></span><span style=display:flex><span>        WxTimer advTimer;
</span></span><span style=display:flex><span>        TimestepConstraint most_restrictive_tc;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Perform frame advance, catch any exception.
</span></span></span><span style=display:flex><span>        advTimer.startTimer();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            most_restrictive_tc <span style=color:#f92672>=</span> advance(frame_stop_time);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>catch</span> (WxExcept wxe)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            infStrm <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Exception caught, simulation exiting. See error log for details.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            errStrm <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>Exception caught in wxm::wmsolver::solve() at t = &#34;</span> <span style=color:#f92672>&lt;&lt;</span> getCurrentTime() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>            errStrm <span style=color:#f92672>&lt;&lt;</span> wxe.what() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>            exit(EXIT_FAILURE);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        advTimer.stopTimer();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Report on frame advance
</span></span></span><span style=display:flex><span>        infStrm <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Advanced from frame &#34;</span> <span style=color:#f92672>&lt;&lt;</span> getCurrentFrame() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; to &#34;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>&lt;&lt;</span> getCurrentFrame() <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; in &#34;</span> <span style=color:#f92672>&lt;&lt;</span> advTimer.timeElapsedAsString()
</span></span><span style=display:flex><span>                <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;. &#34;</span>;
</span></span><span style=display:flex><span>        infStrm <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Current dt = &#34;</span> <span style=color:#f92672>&lt;&lt;</span> getDt() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Report the most restrictive tc among each frame
</span></span></span><span style=display:flex><span>        infStrm <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Most restrictive timestep constraint this period was:</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>        infStrm <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>{dt = &#34;</span> <span style=color:#f92672>&lt;&lt;</span> most_restrictive_tc.getDt() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;physics = &#39;&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>most_restrictive_tc.getPhysics() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;&#39;, &#34;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;x = (&#34;</span> <span style=color:#f92672>&lt;&lt;</span> most_restrictive_tc.getX()[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>&lt;&lt;</span> most_restrictive_tc.getX()[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>&lt;&lt;</span> most_restrictive_tc.getX()[<span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span>                <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;)}</span><span style=color:#ae81ff>\n\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Walltime report in the debug stream
</span></span></span><span style=display:flex><span>        wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.print_timings(debStrm);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        incrementCurrentFrame();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// upon completing the all specified simulation, run EndOnly steps
</span></span></span><span style=display:flex><span>    debStrm <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>Running EndOnly steps...</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    endOnly();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Walltime report
</span></span></span><span style=display:flex><span>    wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.print_timings(infStrm);
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></details><h3 id=pre-solve-actions>Pre-solve Actions<a class=anchor href=#pre-solve-actions>#</a></h3><ul><li><p>First, we run through the <code>presolve</code> steps:</p><details><summary><code>wmsolver.cc: void WmSolver::presolve()</code></summary><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>void</span> WmSolver<span style=color:#f92672>::</span>presolve()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// fetch stream for logging messages
</span></span></span><span style=display:flex><span>    WxLogger<span style=color:#f92672>*</span> log <span style=color:#f92672>=</span> WxLogger<span style=color:#f92672>::</span>get(<span style=color:#e6db74>&#34;warpx-root.console&#34;</span>);
</span></span><span style=display:flex><span>    WxLogStream infStrm <span style=color:#f92672>=</span> log<span style=color:#f92672>-&gt;</span>getInfoStream();
</span></span><span style=display:flex><span>    WxLogStream debStrm <span style=color:#f92672>=</span> log<span style=color:#f92672>-&gt;</span>getDebugStream();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>bool</span> fromRestart <span style=color:#f92672>=</span> (getCurrentFrame() <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// initialize hostactions
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> ha : _hostActions)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        ha.second<span style=color:#f92672>-&gt;</span>init();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// initialize subsolvers
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> ss : _subSolvers)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        ss.second<span style=color:#f92672>-&gt;</span>init();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Run the initialization steps
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (fromRestart)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// run startOnly subsolvers
</span></span></span><span style=display:flex><span>        debStrm <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Running Restart steps...</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        restart();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// run startOnly subsolvers
</span></span></span><span style=display:flex><span>        debStrm <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Running StartOnly steps...</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        startOnly();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}</span></span></code></pre></div></details>- Call the optional `init()` function for each defined host action and sub-solver
- Then, we perform a single `ha->step()` for each host action in the sim's `start_only_group` list. Per the definition in the parent `WxStepper` class, the `step()` method for a host action must advance the state of the object by the assigned time step dt, getDt(). This is where we set the initial conditions for each defined variable. In warpy, these are defined by supplying a list of variable adjusters to the `initial_conditions` parameter of a `warpy.dg_sim` object.
- For a `va_runner` host action, `step()` means:
- For each variable adjuster in the host action, call `va->solve(time, variables_)` to update `variables_` as appropriate for the current time. In doing so, we need to look up the local patch arrays for the variables being adjusted, loading the physical geometry (e.g. `(x,y,z)`, `(dx, dy, dz)`) from the basis for element in the patch, and evaluating each `WmApplication` in the application list for this variable adjuster on each element in the patch.</li></ul><h3 id=main-loop>Main Loop<a class=anchor href=#main-loop>#</a></h3><ul><li>In the main loop, we try to advance the solution from the current frame (0 at the start) to the next frame until we reach the end of the time interval (the last frame). The total number of frames we need to advance is the total number of write-out steps specified in the input file. For example, if our input file has <code>Time = [0, 10.0]</code> and <code>Out = 100</code> in the top-level <code>&lt;sim></code> block, we will have 100 frames that correspond with <code>t = [0.0, 0.1, 0.2, ..., 10.0]</code>. Each pass of the <code>for (size_t i = getCurrentFrame(); i &lt; _nout; ++i)</code> loop calls <code>WmSolver::advance()</code> to advance to the next frame.</li><li>In between each frame, we write out informational log messages (that show the amount of actual time we took to advance to the next frame and the value of the most restrictive timestep) to provide some feedback while the sim is running.</li></ul><details><summary><code>wmsolver.cc: TimestepConstraint WmSolver::advance()</code></summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span>
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>pair<span style=color:#f92672>&lt;</span>TimestepConstraint, TimestepDecision<span style=color:#f92672>&gt;</span> WmSolver<span style=color:#f92672>::</span>advance(real tend)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    WxLogger<span style=color:#f92672>*</span> log <span style=color:#f92672>=</span> WxLogger<span style=color:#f92672>::</span>get(<span style=color:#e6db74>&#34;warpx-root.console&#34;</span>);
</span></span><span style=display:flex><span>    WxLogStream debStrm <span style=color:#f92672>=</span> log<span style=color:#f92672>-&gt;</span>getDebugStream();
</span></span><span style=display:flex><span>    WxLogStream infStrm <span style=color:#f92672>=</span> log<span style=color:#f92672>-&gt;</span>getInfoStream();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> nstep <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> tstart <span style=color:#f92672>=</span> getCurrentTime();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// The limit_dt is smallest reasonable time step considering numerical precision.
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> real limit_dt <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>max(std<span style=color:#f92672>::</span>fabs(tend), std<span style=color:#f92672>::</span>fabs(tstart)) <span style=color:#f92672>*</span> <span style=color:#ae81ff>100.0</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>                          std<span style=color:#f92672>::</span>numeric_limits<span style=color:#f92672>&lt;</span>real<span style=color:#f92672>&gt;::</span>epsilon();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    WxMsgBase<span style=color:#f92672>&amp;</span> msg <span style=color:#f92672>=</span> getMsg();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Initialize variables for tracking the smallest physics time step constraint
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>//  and the smallest time step used during this frame
</span></span></span><span style=display:flex><span>    TimestepConstraint most_restrictive_tc <span style=color:#f92672>=</span> TimestepConstraint();
</span></span><span style=display:flex><span>    TimestepDecision smallest_td <span style=color:#f92672>=</span> TimestepDecision();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Advance solution using time-stepper of choice until time reaches
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// end time of current frame, minus some small delta. WHY??
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> real limit_t <span style=color:#f92672>=</span> tend <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>5</span> <span style=color:#f92672>*</span> std<span style=color:#f92672>::</span>numeric_limits<span style=color:#f92672>&lt;</span>real<span style=color:#f92672>&gt;::</span>epsilon());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (getCurrentTime() <span style=color:#f92672>&lt;</span> limit_t)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If flexible frame write outs not allowed, chose dt that will not exceed
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>// frame interval.
</span></span></span><span style=display:flex><span>        real t <span style=color:#f92672>=</span> getCurrentTime();
</span></span><span style=display:flex><span>        real dt_try <span style=color:#f92672>=</span> _timestep_status.getDtToTry();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>flexible_writeout <span style=color:#f92672>&amp;&amp;</span> dt_try <span style=color:#f92672>&gt;</span> limit_t <span style=color:#f92672>-</span> t)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            dt_try <span style=color:#f92672>=</span> limit_t <span style=color:#f92672>-</span> t;
</span></span><span style=display:flex><span>            std<span style=color:#f92672>::</span>stringstream expl;
</span></span><span style=display:flex><span>            expl <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;dt of &#34;</span> <span style=color:#f92672>&lt;&lt;</span> _timestep_status.getDtToTry()  <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; limited to &#34;</span>  <span style=color:#f92672>&lt;&lt;</span> dt_try
</span></span><span style=display:flex><span>                 <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; to arrive at frame end time.&#34;</span>;
</span></span><span style=display:flex><span>            TimestepDecision td <span style=color:#f92672>=</span> TimestepDecision(
</span></span><span style=display:flex><span>                true, dt_try , std<span style=color:#f92672>::</span>make_shared<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span>(expl.str()));
</span></span><span style=display:flex><span>            _timestep_status.setTdToTry(td);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Take the time step, which will also update _timestep_status
</span></span></span><span style=display:flex><span>        debStrm <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;  Attempting time step &#34;</span> <span style=color:#f92672>&lt;&lt;</span> nstep <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; with dt = &#34;</span> <span style=color:#f92672>&lt;&lt;</span> dt_try <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        debStrm <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;    Explanation: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>_timestep_status.getTryExplanation() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        step_dt(limit_dt);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> dt_taken <span style=color:#f92672>=</span>  _timestep_status.getDtTaken();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> dt_next <span style=color:#f92672>=</span> _timestep_status.getDtNext();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> num_trys <span style=color:#f92672>=</span> _timestep_status.getNumTrys();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Let user know that the step has ended
</span></span></span><span style=display:flex><span>        debStrm <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;  Time step &#34;</span> <span style=color:#f92672>&lt;&lt;</span> nstep <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; successful after &#34;</span> <span style=color:#f92672>&lt;&lt;</span> num_trys
</span></span><span style=display:flex><span>                <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; attempts for t = &#34;</span> <span style=color:#f92672>&lt;&lt;</span> t <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; -&gt; &#34;</span> <span style=color:#f92672>&lt;&lt;</span> getCurrentTime() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        setDt(dt_next);
</span></span><span style=display:flex><span>        most_restrictive_tc <span style=color:#f92672>=</span> TimestepConstraint<span style=color:#f92672>::</span>minDt(<span style=color:#f92672>*</span>_timestep_status.getConstraint(), most_restrictive_tc);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (_timestep_status.getDtTaken() <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) <span style=color:#75715e>// Ignore initial time step, which always has dt=0
</span></span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            smallest_td <span style=color:#f92672>=</span> TimestepDecision<span style=color:#f92672>::</span>minDt(smallest_td, _timestep_status.getTdTaken());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        _timestep_status.updateForNextStep();
</span></span><span style=display:flex><span>        <span style=color:#f92672>++</span>nstep;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> std<span style=color:#f92672>::</span>make_pair(most_restrictive_tc, smallest_td);
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></details><ul><li>Note that within <code>advance()</code>, we have a <code>while (getCurrentTime() &lt; limit_t)</code> loop to increment forwards in time. We continue stepping until we have reached the next frame, which could require many many individual <code>dt</code> timesteps.</li><li>On the first step, the solver attempts to advance time by the <code>dt_controller</code>&rsquo;s initial <code>dt</code>. Subsequent steps may try to advance by a larger or smaller <code>dt</code> if the <code>dt_controller</code> provided in the input file is not a <code>time_stepper.fixed_dt</code>.</li><li>For each host action in the per-step group, we tick forward with <code>host_action->step()</code><ul><li><p>We can peek at <code>tools/warpy/dg_sim.py</code> to see what host actions should be the per-step group for a DG sim. With some abbreviation, we see:</p><details><summary><code>tools/warpy/dg_sim.py: dg_sim.__init__()</code></summary><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># w_group is the group of writer host actions provided in the warpy input file</span>
</span></span><span style=display:flex><span>w_group <span style=color:#f92672>=</span> solver_sequence<span style=color:#f92672>.</span>sequence_group(name<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;write_group&#39;</span>, actions<span style=color:#f92672>=</span>writers)
</span></span><span style=display:flex><span><span style=color:#75715e># ps_group contains the temporal solvers provided in the warpy input file,</span>
</span></span><span style=display:flex><span><span style=color:#75715e># sandwiched between any optional pre- or post-time-integration actions</span>
</span></span><span style=display:flex><span>ps_group <span style=color:#f92672>=</span> solver_sequence<span style=color:#f92672>.</span>sequence_group(
</span></span><span style=display:flex><span>  name<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;perstep_group&#39;</span>,
</span></span><span style=display:flex><span>  actions<span style=color:#f92672>=</span>pre_ti_host_actions <span style=color:#f92672>+</span> temporal_solvers <span style=color:#f92672>+</span> post_ti_host_actions
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#75715e># swap_group</span>
</span></span><span style=display:flex><span>swapper <span style=color:#f92672>=</span> host_actions<span style=color:#f92672>.</span>swapper(
</span></span><span style=display:flex><span>  name<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;swapper&#39;</span>,
</span></span><span style=display:flex><span>  srcs<span style=color:#f92672>=</span>[v<span style=color:#f92672>.</span>name(<span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>for</span> v <span style=color:#f92672>in</span> evolve_vars],
</span></span><span style=display:flex><span>  dsts<span style=color:#f92672>=</span>[v<span style=color:#f92672>.</span>name(v<span style=color:#f92672>.</span>output_stage <span style=color:#66d9ef>if</span> (hasattr(v, <span style=color:#e6db74>&#39;output_stage&#39;</span>)) <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>None</span>) <span style=color:#66d9ef>for</span> v <span style=color:#f92672>in</span> evolve_vars]
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>swap_group <span style=color:#f92672>=</span> solver_sequence<span style=color:#f92672>.</span>sequence_group(name<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;swap_group&#39;</span>, actions<span style=color:#f92672>=</span>[swapper])
</span></span><span style=display:flex><span><span style=color:#75715e># So per-step host actions are the writers, followed by the temporal solvers, followed by swappers</span>
</span></span><span style=display:flex><span>ps_step <span style=color:#f92672>=</span> [w_group, ps_group, swap_group]
</span></span><span style=display:flex><span>ss <span style=color:#f92672>=</span> solver_sequence<span style=color:#f92672>.</span>solver_sequence(
</span></span><span style=display:flex><span>  start_only<span style=color:#f92672>=</span>so_step,
</span></span><span style=display:flex><span>  per_step<span style=color:#f92672>=</span>ps_step,
</span></span><span style=display:flex><span>  per_redo_per_step<span style=color:#f92672>=</span>r_step,
</span></span><span style=display:flex><span>  end_only<span style=color:#f92672>=</span>eo_step,
</span></span><span style=display:flex><span>  restart<span style=color:#f92672>=</span>res_step
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>super(dg_sim, self)<span style=color:#f92672>.</span><span style=color:#a6e22e>__init__</span>(solver_sequence<span style=color:#f92672>=</span>ss, <span style=color:#f92672>...</span>)</span></span></code></pre></div></details></li><li><p>The big one is of course the temporal solver. For pretty much everything we&rsquo;re using WARPXM for, that&rsquo;s going to be a <code>Kind = explicit_runge_kutta</code> host action (the implicit solver still exists but is rarely used), which maps to a <code>WmTemporalSolver_RK</code>.</p><details><summary><code>src/dfem/temporal_solvers/wmtemporalsolver_rk.cc: WxStepperStatus WmTemporalSolver_RK::step()</code></summary><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span>WxStepperStatus WmTemporalSolver_RK<span style=color:#f92672>::</span>step()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.start(<span style=color:#e6db74>&#34;rk_solver/step&#34;</span>);
</span></span><span style=display:flex><span>    time_t time <span style=color:#f92672>=</span> getCurrentTime();
</span></span><span style=display:flex><span>    time_t dt <span style=color:#f92672>=</span> getDt();
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>TimestepConstraint<span style=color:#f92672>&gt;</span> sugg_tc <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>make_shared<span style=color:#f92672>&lt;</span>TimestepConstraint<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> rk_stage <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; rk_stage <span style=color:#f92672>&lt;</span> scheme_<span style=color:#f92672>-&gt;</span>getNumStages(); rk_stage<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> real current_time <span style=color:#f92672>=</span> time <span style=color:#f92672>+</span> scheme_<span style=color:#f92672>-&gt;</span>getTimeUpdate(rk_stage) <span style=color:#f92672>*</span> dt;
</span></span><span style=display:flex><span>        variables_type<span style=color:#f92672>&amp;</span> q_n <span style=color:#f92672>=</span> variables_[rk_stage];
</span></span><span style=display:flex><span>        variables_type<span style=color:#f92672>&amp;</span> q_p <span style=color:#f92672>=</span> variables_[rk_stage <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// zero out q_p which are temporal vars
</span></span></span><span style=display:flex><span>        fill_local(rk_stage <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// TODO: this is only here until zero_fluxes is implemented with scopes
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> ss : spatial_solvers_)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            ss<span style=color:#f92672>-&gt;</span>zero_fluxes();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// run all variable adjusters
</span></span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.start(<span style=color:#e6db74>&#34;variable_adjusters&#34;</span>);
</span></span><span style=display:flex><span>            size_t idx <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (size_t i <span style=color:#f92672>=</span> min_priority; i <span style=color:#f92672>&lt;=</span> max_priority; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.start(<span style=color:#e6db74>&#34;priority = &#34;</span> <span style=color:#f92672>+</span> std<span style=color:#f92672>::</span>to_string(i));
</span></span><span style=display:flex><span>                wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.start(<span style=color:#e6db74>&#34;solve&#34;</span>);
</span></span><span style=display:flex><span>                size_t pidx <span style=color:#f92672>=</span> idx;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (idx <span style=color:#f92672>&lt;</span> va_priorities.size() <span style=color:#f92672>&amp;&amp;</span> va_priorities[idx] <span style=color:#f92672>&lt;=</span> i)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.start(adjusters_[idx]<span style=color:#f92672>-&gt;</span>name(<span style=color:#e6db74>&#34;&#34;</span>) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;/solve&#34;</span>);
</span></span><span style=display:flex><span>                    adjusters_[idx]<span style=color:#f92672>-&gt;</span>solve(current_time, q_n, dt);
</span></span><span style=display:flex><span>                    <span style=color:#f92672>++</span>idx;
</span></span><span style=display:flex><span>                    wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.stop();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.stop(); <span style=color:#75715e>// solve
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.start(<span style=color:#e6db74>&#34;barrier&#34;</span>);
</span></span><span style=display:flex><span>                idx <span style=color:#f92672>=</span> pidx;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (idx <span style=color:#f92672>&lt;</span> va_priorities.size() <span style=color:#f92672>&amp;&amp;</span> va_priorities[idx] <span style=color:#f92672>&lt;=</span> i)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.start(adjusters_[idx]<span style=color:#f92672>-&gt;</span>name(<span style=color:#e6db74>&#34;&#34;</span>) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;/barrier&#34;</span>);
</span></span><span style=display:flex><span>                    adjusters_[idx]<span style=color:#f92672>-&gt;</span>Barrier(getMsg(), current_time, q_n);
</span></span><span style=display:flex><span>                    <span style=color:#f92672>++</span>idx;
</span></span><span style=display:flex><span>                    wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.stop();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.stop(); <span style=color:#75715e>// barrier
</span></span></span><span style=display:flex><span>                wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.stop(); <span style=color:#75715e>// priority
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.start(<span style=color:#e6db74>&#34;va_rk_sync&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Initiate syncing on every MPI rank
</span></span></span><span style=display:flex><span>                start_sync(rk_stage);
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Wait for syncing to finish
</span></span></span><span style=display:flex><span>                finish_sync(rk_stage);
</span></span><span style=display:flex><span>                wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.stop(); <span style=color:#75715e>// va_rk_sync
</span></span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.stop(); <span style=color:#75715e>// variable_adjusters
</span></span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// run the spatial solvers
</span></span></span><span style=display:flex><span>        wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.start(<span style=color:#e6db74>&#34;spatial_solvers&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> ss : spatial_solvers_)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.start(ss<span style=color:#f92672>-&gt;</span>name(<span style=color:#e6db74>&#34;&#34;</span>) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;/solve&#34;</span>);
</span></span><span style=display:flex><span>            std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>TimestepConstraint<span style=color:#f92672>&gt;</span> tc <span style=color:#f92672>=</span> ss<span style=color:#f92672>-&gt;</span>solve(current_time, q_n, q_p);
</span></span><span style=display:flex><span>            wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.stop(); <span style=color:#75715e>// ss_rk_solve
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Comparing spatial_solver&#39;s suggested time step with current minimum
</span></span></span><span style=display:flex><span>            <span style=color:#75715e>// suggested time step. Updating sugg_tc if new minimum
</span></span></span><span style=display:flex><span>            <span style=color:#f92672>*</span>sugg_tc <span style=color:#f92672>=</span> TimestepConstraint<span style=color:#f92672>::</span>minDt(<span style=color:#f92672>*</span>sugg_tc, <span style=color:#f92672>*</span>tc);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.start(ss<span style=color:#f92672>-&gt;</span>name(<span style=color:#e6db74>&#34;&#34;</span>) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;/barrier&#34;</span>);
</span></span><span style=display:flex><span>            ss<span style=color:#f92672>-&gt;</span>Barrier(getMsg(), current_time, q_p);
</span></span><span style=display:flex><span>            wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.stop(); <span style=color:#75715e>// ss_rk_barrier
</span></span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// rhs is now in q_p; need to accumulate with previous q&#39;s to get actual q_p
</span></span></span><span style=display:flex><span>        scheme_<span style=color:#f92672>-&gt;</span>calc_stage(rk_stage, temporal_vars_, variables_, dt);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.start(<span style=color:#e6db74>&#34;ss_rk_sync&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Initiate syncing on every MPI rank
</span></span></span><span style=display:flex><span>        start_sync(rk_stage <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Wait for syncing to finish
</span></span></span><span style=display:flex><span>        finish_sync(rk_stage <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.stop(); <span style=color:#75715e>// ss_rk_sync
</span></span></span><span style=display:flex><span>        wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.stop(); <span style=color:#75715e>// spatial_solvers
</span></span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.stop(); <span style=color:#75715e>// for &#34;rk_solver/step&#34;
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// TODO: how to get time step limit to take into account sources/diffusion/advection?
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>WxStepperStatus</span>(dt <span style=color:#f92672>&lt;=</span> sugg_tc<span style=color:#f92672>-&gt;</span>getDt(), sugg_tc);
</span></span><span style=display:flex><span>}</span></span></code></pre></div></details></li></ul></li></ul><p>The Runge-Kutta temporal solver has multiple &ldquo;stages&rdquo;, depending on the temporal order specified in the input file. These stages are the standard Runge-Kutta intermediate approximations of the solution in between <code>t</code> and <code>t + dt</code> which are combined in a weighted average to advance the solution. For each stage:</p><ul><li>We start with the current state in <code>q_n</code>. We then run any variable adjusters associated with the temporal solver. In the case of the <code>advection.py</code> example, we use a shock-capturing limiter (<code>warpy.variable_adjusters.limiters.dg_moe_rossmanith</code>) which enforces local bounds on variables by damping the high-order corrections. These can modify the value of <code>q_n</code> before the spatial solvers act on it.</li><li>We perform a full <code>start_sync()</code>/<code>finish_sync()</code> to sync the MPI halo data.</li><li>The DG spatial solver comes next, and this is where the really heavy lifting happens: <code>ndg_t::solve(const real time, const variables_type& input, variables_type& output)</code>. The actual flux calculations are up to the <code>WmApplication</code>(s) that we&rsquo;ve defined in our input file. To express the physics of the problem in the language of DG, an application can define:<ul><li><code>numerical_flux()</code>: Compute boundary flux over the surface of a DG element</li><li><code>internal_flux()</code>: Compute volume flux within a DG element</li><li><code>source()</code>: Contribute a source/sink term</li><li><code>bc_q()</code>: Set the value of &ldquo;ghost&rdquo; nodes on the domain boundary</li><li><code>bcNumericalFlux()</code>: Conpute boundary flux for element faces on the domain boundary</li></ul></li></ul><p>I don&rsquo;t pretend to fully understand the DG implementation in WARPXM just yet, so I may get some things slightly wrong here. As far as I can tell, the calculation of $\pdv{q}{t}$ has been intentionally broken up into three separate &ldquo;kernel&rdquo; methods: <code>in_kernel</code>, <code>ex_kernel</code>, and <code>rhs_kernel</code>. In this case, use of the word &ldquo;<a href=https://en.wikipedia.org/wiki/Compute_kernel>kernel</a>&rdquo; is meant to indicate that these are the inner-most methods where the real number crunching happens.</p><ol><li><code>in_kernel</code>: Compute the internal flux within each DG element<ul><li>If there are apps with sources that require computing Gaussian quadrature, we compute those quadrature points and call <code>app->source()</code> to allow the app to do its thing and compute the source flux on the element.</li><li>After loading the variables and node geometry for the current patch, the internal flux computation is all up to the application when we call <code>app->internal_flux()</code> for each app to compute the internal flux on the element.</li></ul></li><li><code>ex_kernel</code>: Compute the flux across each face of the element. For each app we call <code>app->numerical_flux()</code> to get the flux for each element face. Then, for the boundary conditions, we collect the set of boundary faces in the patch and for each one we find applications that supply a <code>bcNumericalFlux()</code> function and call it, summing up the results.</li><li><code>rhs_kernel</code>: This is basically just combining the individual terms together into the right-hand-side of eq. 3.3.21 from <a href="https://www.proquest.com/dissertations-theses/domain-hybridized-plasma-model-using/docview/2594528326/se-2?accountid=14784">Iman&rsquo;s dissertation</a>:
<span>\[\underbrace{\pdv{}{t} q_{ij} ^ \lambda}_{\text{rhs\_kernel}} = \underbrace{J_ {ml} ^\lambda \Upsilon _{jlk} f^ \lambda _{imk}}_{\text{in\_kernel}} - \underbrace{\sum_{\gamma \in \tilde{\Gamma} _\lambda} G_{\lambda \gamma} \Xi _{jk} ^{\lambda \gamma} F_{ik} ^{\lambda \gamma} + \Psi _{jk} s_{ik} ^{\lambda}}_{\text{ex\_kernel}}\]
</span>where $f^\lambda _{imk}$ is the internal flux computed above, $F _{ik} ^{\lambda \gamma}$ is the external flux computed above, $s _ {ik} ^{\lambda}$ is the source flux, and $ J _ {ml} ^\lambda \Upsilon _ {jlk} $, $ G _ {\lambda \gamma} \Xi _ {jk} ^{\lambda \gamma}$, and $\Psi _ {jk}$ are computed directly from the geometry and nodal basis for each element.</li></ol><ul><li><p><code>rhs_kernel</code> dumps its output into <code>variables_[rk_stage + 1]</code>. Then, based on the RK scheme <code>scheme_->calc_stage(rk_stage, temporal_vars_, variables_, dt)</code> accumulates the results for the stage. We get another <code>start_sync()</code>/<code>finish_sync()</code> before moving on to the next stage.</p></li><li><p>Each of these flux calculations and patch processes results may produce a timestep constraint, which gives the minimum allowable <code>dt</code> for the next step based on e.g. CFL condition. We always take the smallest constraint before moving forward.</p></li><li><p>Finally, once we&rsquo;ve (hopefully) stepped all the way to the final frame, each host action in the end-only-group (typically just the writers) gets a <code>step()</code> to write out the final frame&rsquo;s data, and the sim is done!</p></li></ul><h3 id=class-diagrams>Class diagrams<a class=anchor href=#class-diagrams>#</a></h3><p>When trying to visualize how the different classes in the WARPXM codebase interact, I found it useful at some points to refer to class hierarchy diagrams. These diagrams can ge benerated to show the inheritance hierarchy of all classes in the C++ code from top (parent) to bottom (child). These diagrams can be generated as part of the Doxygen documentation by setting <code>CLASS_DIAGRAMS = true</code> and <code>HAVE_DOT = true</code> in the <a href=https://github.com/UW-Computational-Plasma-Group/warpxm/blob/master/doxyfile.in>doxygen input file</a> and re-building the documentation. Need to make sure that <a href=https://www.graphviz.org/>graphviz</a> is installed locally in order to draw the generated diagrams.</p><p>Class diagrams generated by Doxygen showing all the different implementations of patch processes we&rsquo;ve currently got:</p><p align=center><img alt=img/research/warpxm/classdiagram-WmPatchProcess.png src=/r/img/research/warpxm/classdiagram-WmPatchProcess.png></p><p align=center><img alt=img/research/warpxm/classdiagram-variable_adjuster_t.png src=/r/img/research/warpxm/classdiagram-variable_adjuster_t.png></p><h2 id=lets-try-to-go-through-the-same-exercise-but-for-the-ndg_kinetic-solver>Let&rsquo;s try to go through the same exercise, but for the ndg_kinetic solver<a class=anchor href=#lets-try-to-go-through-the-same-exercise-but-for-the-ndg_kinetic-solver>#</a></h2><p>I&rsquo;m interested in the kinetic solver in particular. It would be useful to follow the same steps for an input file that uses the <code>dg_kinetic</code> solver.</p><h2 id=setup-1>Setup<a class=anchor href=#setup-1>#</a></h2><p>The first difference is in the <code>WmSolver::setup</code> step that comes within <code>WmSimulation::setup</code> as previously discussed. The kinetic spatial solver is a patch action,</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div></div><div></div></div><div class="flex flex-wrap justify-between"><span><a href=/r/notes/research/warpxm-101/ class="flex align-center"><img src=/r/icons/backward.svg class=book-icon alt=Backward>
<span>WARPXM 101 - Getting Started</span>
</a></span><span><a href=/r/notes/research/warpxm-201/ class="flex align-center"><span>WARPXM 201 - Unstructured Geometry</span>
<img src=/r/icons/forward.svg class=book-icon alt=Forward></a></span></div><div class=book-comments></div><script>(function(){document.querySelectorAll("pre:has(code)").forEach(e=>{e.addEventListener("click",e.focus),e.addEventListener("copy",function(t){if(t.preventDefault(),navigator.clipboard){const t=window.getSelection().toString()||e.textContent;navigator.clipboard.writeText(t)}})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#what-happens-when-you-press-go>What Happens When You Press Go?</a><ul><li><a href=#entrypoint>Entrypoint</a></li><li><a href=#setup>Setup</a><ul><li><a href=#domain-setup>Domain Setup</a></li><li><a href=#variable-setup>Variable Setup</a></li><li><a href=#host-action-initialization>Host Action Initialization</a></li></ul></li><li><a href=#solve>Solve</a><ul><li><a href=#pre-solve-actions>Pre-solve Actions</a></li><li><a href=#main-loop>Main Loop</a></li><li><a href=#class-diagrams>Class diagrams</a></li></ul></li><li><a href=#lets-try-to-go-through-the-same-exercise-but-for-the-ndg_kinetic-solver>Let&rsquo;s try to go through the same exercise, but for the ndg_kinetic solver</a></li><li><a href=#setup-1>Setup</a></li></ul></li></ul></nav></div></aside></main></body></html>