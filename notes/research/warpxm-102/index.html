<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="\[\] What Happens When You Press Go? # Following the sequence of events that take place in a WARPXM simulation by stepping through in the debugger has helped me to understand the code structure and concepts. I would highly recommend going so at least once. I have tried to explain what happens in plain English in the hopes that it will help me (and maybe someone else) to better understand how things are structured and what to expect when working with WARPXM."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="WARPXM 102 - Code Structure"><meta property="og:description" content="\[\] What Happens When You Press Go? # Following the sequence of events that take place in a WARPXM simulation by stepping through in the debugger has helped me to understand the code structure and concepts. I would highly recommend going so at least once. I have tried to explain what happens in plain English in the hopes that it will help me (and maybe someone else) to better understand how things are structured and what to expect when working with WARPXM."><meta property="og:type" content="article"><meta property="og:url" content="https://peppyhare.github.io/r/notes/research/warpxm-102/"><meta property="article:section" content="notes"><meta property="article:modified_time" content="2023-12-14T14:32:58-08:00"><title>WARPXM 102 - Code Structure | My Notes</title>
<link rel=manifest href=/r/manifest.json><link rel=icon href=/r/favicon.png><link rel=stylesheet href=/r/book.min.e2c0ab9752977a3bbfa75b7a9a3dc3931afe9d51052c718a0df7854197eff1bd.css integrity="sha256-4sCrl1KXeju/p1t6mj3Dkxr+nVEFLHGKDfeFQZfv8b0=" crossorigin=anonymous><script defer src=/r/flexsearch.min.js></script><script defer src=/r/en.search.min.e4532b722e6b34c4b5a7781480c668df77bd0981866f3ec5f8c57b8a9b81f8ed.js integrity="sha256-5FMrci5rNMS1p3gUgMZo33e9CYGGbz7F+MV7ipuB+O0=" crossorigin=anonymous></script><script defer src=/r/sw.min.9e3a83f0b071ebe0141a16a33db93faadb2bdf712473a218febeed35ed243c08.js integrity="sha256-njqD8LBx6+AUGhajPbk/qtsr33Ekc6IY/r7tNe0kPAg=" crossorigin=anonymous></script><link rel=preload href=/r/katex/fonts/KaTeX_Main-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/r/katex/fonts/KaTeX_Main-Bold.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/r/katex/fonts/KaTeX_Main-Italic.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/r/katex/fonts/KaTeX_Math-Italic.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/r/katex/fonts/KaTeX_Size2-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/r/katex/fonts/KaTeX_Size3-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/r/fonts/roboto-v27-latin-regular.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/r/fonts/roboto-v27-latin-700.woff2 as=font type=font/woff2 crossorigin=anonymous></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/r/><span>My Notes</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/r/svg/translate.svg class=book-icon alt=Languages>
English</a></label><ul></ul></li></ul><ul><li class=book-section-flat><ul><li class=book-section-flat><input type=checkbox id=section-3c2351b6c36eb8737d2b3aab84ebe41a class=toggle>
<label for=section-3c2351b6c36eb8737d2b3aab84ebe41a class="flex justify-between"><a href=/r/notes/UWAA545/ class="navbutton
book-collapse-section">Computational Methods For Plasmas</a></label><ul><li><a href=/r/notes/UWAA545/01-syllabus/ class=navbutton>Syllabus</a></li><li><a href=/r/notes/UWAA545/02-plasma-models/ class=navbutton>Plasma Models</a></li><li><a href=/r/notes/UWAA545/03-pic-method/ class=navbutton>Particle in Cell Model</a></li><li><a href=/r/notes/UWAA545/04-pic-example/ class=navbutton>PIC - Example Implementation</a></li><li><a href=/r/notes/UWAA545/05-electrodynamic-pic/ class=navbutton>Multidimensional Electrodynamic PIC</a></li><li><a href=/r/notes/UWAA545/06-fluid-models/ class=navbutton>Fluid Models for Plasmas</a></li><li><a href=/r/notes/UWAA545/07-finite-difference-models/ class=navbutton>Finite Difference Methods for MHD</a></li><li><a href=/r/notes/UWAA545/08-mhd-equilibrium/ class=navbutton>MHD Equilibrium Calculations</a></li><li><a href=/r/notes/UWAA545/formulary/ class=navbutton>Formulary</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-6349dd4237c5b36ce5c3738b93bc5885 class=toggle>
<label for=section-6349dd4237c5b36ce5c3738b93bc5885 class="flex justify-between"><a href=/r/notes/UWAA560/ class="navbutton
book-collapse-section">Plasma Diagnostics</a></label><ul><li><a href=/r/notes/UWAA560/01-syllabus/ class=navbutton>Syllabus</a></li><li><a href=/r/notes/UWAA560/02-diagnostic-considerations/ class=navbutton>General Diagnostic Considerations</a></li><li><a href=/r/notes/UWAA560/03-magnetic-field-diagnostics/ class=navbutton>Magnetic Field Diagnostics</a></li><li><a href=/r/notes/UWAA560/04-electrostatic-diagnostics/ class=navbutton>Electrostatic Diagnostics</a></li><li><a href=/r/notes/UWAA560/05-index-of-refraction-measurements/ class=navbutton>Index of Refraction Measurements</a></li><li><a href=/r/notes/UWAA560/06-spectroscopic-measurements/ class=navbutton>Spectroscopic Measurements</a></li><li><a href=/r/notes/UWAA560/90-student-lectures/ class=navbutton>Student Lectures</a></li><li><a href=/r/notes/UWAA560/91-zeeman-spectroscopy/ class=navbutton>My class lecture</a></li><li><a href=/r/notes/UWAA560/formulary/ class=navbutton>Formulary</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-edf338bf880234e7aba93d04934ebde0 class=toggle>
<label for=section-edf338bf880234e7aba93d04934ebde0 class="flex justify-between"><a href=/r/notes/UWAA558/ class="navbutton
book-collapse-section">MHD Theory</a></label><ul><li><a href=/r/notes/UWAA558/01-syllabus/ class=navbutton>Syllabus</a></li><li><a href=/r/notes/UWAA558/02-plasma-models/ class=navbutton>Plasma Models</a></li><li><a href=/r/notes/UWAA558/03-plasma-fluid-model/ class=navbutton>Plasma Fluid Model</a></li><li><a href=/r/notes/UWAA558/04-two-fluid-plasma-model/ class=navbutton>Two-Fluid Plasma Model</a></li><li><a href=/r/notes/UWAA558/05-mhd-model/ class=navbutton>Magnetohydrodynamic (MHD) Model</a></li><li><a href=/r/notes/UWAA558/06-boundary-conditions/ class=navbutton>Boundary Conditions</a></li><li><a href=/r/notes/UWAA558/07-equilibrium-for-fusion/ class=navbutton>Equilibrium for Fusion</a></li><li><a href=/r/notes/UWAA558/08-1d-equilibria/ class=navbutton>1-D Equilibria</a></li><li><a href=/r/notes/UWAA558/09-2d-equilibria/ class=navbutton>2D Equilibria</a></li><li><a href=/r/notes/UWAA558/10-equilibrium-of-3d-configurations/ class=navbutton>Equilibrium of 3D Configurations</a></li><li><a href=/r/notes/UWAA558/11-mhd-stability/ class=navbutton>MHD Stability</a></li><li><a href=/r/notes/UWAA558/formulary/ class=navbutton>Formulary</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-0ab4cc33a17dbfeaac89afca6a70923e class=toggle checked>
<label for=section-0ab4cc33a17dbfeaac89afca6a70923e class="flex justify-between"><a href=/r/notes/research/ class="navbutton
book-collapse-section">Research Notes</a></label><ul><li><a href=/r/notes/research/dgh-datta/ class=navbutton>Electrodynamic Dory-Guest-Harris Instability</a></li><li><a href=/r/notes/research/warpxm-101/ class=navbutton>WARPXM 101 - Getting Started</a></li><li><a href=/r/notes/research/warpxm-102/ class="active navbutton">WARPXM 102 - Code Structure</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-413f74fd9b5926250a41b61f37ddacc6 class=toggle>
<label for=section-413f74fd9b5926250a41b61f37ddacc6 class="flex justify-between"><a href=/r/notes/UWAA557/ class="navbutton
book-collapse-section">Physics of Fusion Plasmas</a></label><ul><li><a href=/r/notes/UWAA557/ch10-0/ class=navbutton>Rules of thumb</a></li><li><a href=/r/notes/UWAA557/ch10-1/ class=navbutton>Statistical Mechanics</a></li><li><a href=/r/notes/UWAA557/ch10-2/ class=navbutton>Review of E&amp;M</a></li><li><a href=/r/notes/UWAA557/ch10-3/ class=navbutton>Lagrange Multipliers</a></li><li><a href=/r/notes/UWAA557/ch11-1/ class=navbutton>Wall-supported Plasma</a></li><li><a href=/r/notes/UWAA557/ch11-2/ class=navbutton>Collisions</a></li><li><a href=/r/notes/UWAA557/ch11-3/ class=navbutton>Oscillations</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-f5aa9ed14dd55f47a51954bafbe42c68 class=toggle>
<label for=section-f5aa9ed14dd55f47a51954bafbe42c68 class="flex justify-between"><a href=/r/notes/UWAA543/ class="navbutton
book-collapse-section">Computational CFD</a></label><ul><li><a href=/r/notes/UWAA543/ch20-1/ class=navbutton>Introduction to Computational CFD</a></li><li><a href=/r/notes/UWAA543/ch20-2/ class=navbutton>Governing Equations</a></li><li><a href=/r/notes/UWAA543/ch20-3/ class=navbutton>Reduced Models</a></li><li><a href=/r/notes/UWAA543/ch20-4/ class=navbutton>Equation Types</a></li><li><a href=/r/notes/UWAA543/ch20-5/ class=navbutton>Panel Method</a></li><li><a href=/r/notes/UWAA543/ch21-1/ class=navbutton>Finite Difference Algorithms</a></li><li><a href=/r/notes/UWAA543/ch21-2/ class=navbutton>Explicit Finite Difference Algorithms</a></li><li><a href=/r/notes/UWAA543/ch21-3/ class=navbutton>Finite Difference and Finite Volume Methods</a></li><li><a href=/r/notes/UWAA543/ch21-4/ class=navbutton>Implicit Algorithms</a></li><li><a href=/r/notes/UWAA543/ch21-5/ class=navbutton>Numerical Boundary Conditions</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-fec96caaff8d6393621cb5c836aaffe6 class=toggle>
<label for=section-fec96caaff8d6393621cb5c836aaffe6 class="flex justify-between"><a href=/r/notes/UWAA556/ class="navbutton
book-collapse-section">Plasma Waves</a></label><ul><li><a href=/r/notes/UWAA556/ch01-1/ class=navbutton>Mathematical review</a></li><li><a href=/r/notes/UWAA556/ch02-1/ class=navbutton>Plasma Waves in General Dielectric Media</a></li><li><a href=/r/notes/UWAA556/ch02-2/ class=navbutton>Wave Properties in Cold Unmagnetized Plasma</a></li><li><a href=/r/notes/UWAA556/ch02-3/ class=navbutton>Cold Magnetized Plasma Dispersion Relation</a></li><li><a href=/r/notes/UWAA556/ch02-4/ class=navbutton>The CMA Diagram</a></li><li><a href=/r/notes/UWAA556/ch03-1/ class=navbutton>Introduction to Kinetic Theory</a></li><li><a href=/r/notes/UWAA556/ch03-2/ class=navbutton>Landau Damping</a></li><li><a href=/r/notes/UWAA556/ch03-3/ class=navbutton>Waves in Hot Magnetized Plasma</a></li><li><a href=/r/notes/UWAA556/ch04-1/ class=navbutton>Fluid stuff</a></li><li><a href=/r/notes/UWAA556/ch04-2/ class=navbutton>Quasi-Linear Theory</a></li><li><a href=/r/notes/UWAA556/ch05-1/ class=navbutton>Diffusion and Resistivity</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-8fb1297aabc80ae7754972056ff59a2d class=toggle>
<label for=section-8fb1297aabc80ae7754972056ff59a2d class="flex justify-between"><a href=/r/notes/problems/ class="navbutton
book-collapse-section">Worked Problems</a></label><ul><li><a href=/r/notes/problems/gurnett/ch02/ class=navbutton>Characteristic Parameters of a Plasma</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-3cae707fb8713119044de8d3ecbe7266 class=toggle>
<label for=section-3cae707fb8713119044de8d3ecbe7266 class="flex justify-between"><a role=button class="navbutton
book-collapse-section">Scratch</a></label><ul><li><a href=/r/notes/scratch/colors/ class=navbutton>Adding Color</a></li><li><a href=/r/notes/scratch/crews2018/ class=navbutton>Crews (2018)</a></li><li><a href=/r/notes/scratch/datta2021/ class=navbutton>Datta (2021)</a></li><li><a href=/r/notes/scratch/drawing/ class=navbutton>Drawing Diagrams</a></li><li><a href=/r/notes/scratch/goedbloed/ class=navbutton>Goedbloed (2019)</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-ee5e070eb25b63f2c377d750d37f67ae class=toggle>
<label for=section-ee5e070eb25b63f2c377d750d37f67ae class="flex justify-between"><a href=/r/notes/griffiths/ class="navbutton
book-collapse-section">Griffiths Introduction to Electrodynamics</a></label><ul><li><a href=/r/notes/griffiths/ch1-1/ class=navbutton>Vector Algebra</a></li><li><a href=/r/notes/griffiths/ch1-2/ class=navbutton>Differential Calculus</a></li><li><a href=/r/notes/griffiths/ch1-3/ class=navbutton>Integral Calculus</a></li><li><a href=/r/notes/griffiths/ch1-4/ class=navbutton>Curvilinear Coordinates</a></li><li><a href=/r/notes/griffiths/ch1-5/ class=navbutton>The Dirac Delta Function</a></li><li><a href=/r/notes/griffiths/ch1-6/ class=navbutton>The Theory of Vector Fields</a></li><li><a href=/r/notes/griffiths/ch2-1/ class=navbutton>The Electric Field</a></li><li><a href=/r/notes/griffiths/ch2-2/ class=navbutton>Divergence and Curl of Electrostatic Fields</a></li><li><a href=/r/notes/griffiths/ch2-3/ class=navbutton>Electric Potential</a></li><li><a href=/r/notes/griffiths/ch2-4/ class=navbutton>Work and Energy in Electrostatics</a></li><li><a href=/r/notes/griffiths/ch2-5/ class=navbutton>Conductors</a></li><li><a href=/r/notes/griffiths/ch3-1/ class=navbutton>Laplace's Equation</a></li><li><a href=/r/notes/griffiths/ch3-2/ class=navbutton>The Method of Images</a></li><li><a href=/r/notes/griffiths/ch3-3/ class=navbutton>Separation of Variables</a></li><li><a href=/r/notes/griffiths/ch3-4/ class=navbutton>Multipole Expansion</a></li><li><a href=/r/notes/griffiths/ch4-1/ class=navbutton>Polarization</a></li><li><a href=/r/notes/griffiths/ch4-2/ class=navbutton>The Field of a Polarized Object</a></li><li><a href=/r/notes/griffiths/ch4-3/ class=navbutton>The Electric Displacement</a></li><li><a href=/r/notes/griffiths/ch4-4/ class=navbutton>The Linear Dielectrics</a></li><li><a href=/r/notes/griffiths/ch5-1/ class=navbutton>The Lorentz Force Law</a></li><li><a href=/r/notes/griffiths/ch5-2/ class=navbutton>The Biot-Savart Law</a></li><li><a href=/r/notes/griffiths/ch5-3/ class=navbutton>The Divergence and Curl of B</a></li><li><a href=/r/notes/griffiths/ch5-4/ class=navbutton>Magnetic Vector Potential</a></li><li><a href=/r/notes/griffiths/ch6-1/ class=navbutton>Magnetization</a></li><li><a href=/r/notes/griffiths/ch6-2/ class=navbutton>The Field of a Magnetized Object</a></li><li><a href=/r/notes/griffiths/ch6-3/ class=navbutton>The Auxiliary Field H</a></li><li><a href=/r/notes/griffiths/ch6-4/ class=navbutton>Linear and Nonlinear Media</a></li><li><a href=/r/notes/griffiths/ch7-1/ class=navbutton>Electromotive Force</a></li><li><a href=/r/notes/griffiths/ch7-2/ class=navbutton>Electromagnetic Induction</a></li><li><a href=/r/notes/griffiths/ch7-3/ class=navbutton>Maxwell's Equations</a></li><li><a href=/r/notes/griffiths/ch8-0/ class=navbutton>Phys 544 Introduction</a></li><li><a href=/r/notes/griffiths/ch8-1/ class=navbutton>Charge and Energy</a></li><li><a href=/r/notes/griffiths/ch8-2/ class=navbutton>Momentum</a></li><li><a href=/r/notes/griffiths/ch9-1/ class=navbutton>Electromagnetic Waves in One Dimension</a></li><li><a href=/r/notes/griffiths/ch9-2/ class=navbutton>Wave Equation for E and B</a></li><li><a href=/r/notes/griffiths/ch9-3/ class=navbutton>Electromagnetic Waves in Matter</a></li><li><a href=/r/notes/griffiths/ch9-4/ class=navbutton>Electromagnetic Waves in Conductors</a></li><li><a href=/r/notes/griffiths/ch9-5/ class=navbutton>Guided Waves</a></li><li><a href=/r/notes/griffiths/ch10-1/ class=navbutton>Scalar and Vector Potentials</a></li><li><a href=/r/notes/griffiths/ch10-2/ class=navbutton>Retarded Potentials</a></li><li><a href=/r/notes/griffiths/ch10-3/ class=navbutton>Point Charges</a></li><li><a href=/r/notes/griffiths/ch11-1/ class=navbutton>Dipole Radiation</a></li><li><a href=/r/notes/griffiths/problems-ch3/ class=navbutton>Solved Problems Ch3</a></li><li><a href=/r/notes/griffiths/problems-ch5/ class=navbutton>Solved Problems Ch5</a></li><li><a href=/r/notes/griffiths/problems-ch7/ class=navbutton>Solved Problems Ch7</a></li><li><a href=/r/notes/griffiths/problems-ch9/ class=navbutton>Solved Problems Ch9</a></li></ul></li></ul></li></ul><ul class=book-menu-hugo><li><a href=https://github.com/Peppyhare/r target=_blank rel=noopener>Github</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Hugo Themes</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/r/svg/menu.svg class=book-icon alt=Menu>
</label><strong>WARPXM 102 - Code Structure</strong>
<label for=toc-control><img src=/r/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#what-happens-when-you-press-go>What Happens When You Press Go?</a><ul><li><a href=#entrypoint>Entrypoint</a></li><li><a href=#setup>Setup</a><ul><li><a href=#domain-setup>Domain Setup</a></li><li><a href=#variable-setup>Variable Setup</a></li><li><a href=#host-action-initialization>Host Action Initialization</a></li></ul></li><li><a href=#solve>Solve</a><ul><li><a href=#pre-solve-actions>Pre-solve Actions</a></li><li><a href=#main-loop>Main Loop</a></li><li><a href=#patch-processes>Patch Processes</a></li></ul></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><link rel=stylesheet href=/r/katex/katex.min.css><script defer src=/r/katex/katex.min.js></script><script defer src=/r/katex/auto-render.min.js onload=loadKatex()></script><span>\[\]
</span><script>function loadKatex(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}],throwOnError:!1,trust:e=>["\\htmlId","\\href"].includes(e.command),macros:{"\\lcm":"\\mathop{\\mathrm{lcm}}","\\sen":"\\text{sen}\\,","\\dd":"\\mathop{\\mathrm{d} #1}","\\abs":`\\lvert #1 \\rvert`,"\\dd":"\\text{d}","\\cross":"\\times","\\pdv":"\\frac{\\partial #1}{\\partial #2}","\\curl":`\\nabla \\cross #1`,"\\vu":"\\mathbf{\\hat{#1}}","\\vdot":"\\dot","\\div":`\\nabla \\cdot #1`,"\\grad":`\\nabla`,"\\dv":"\\frac{d\\,#1}{d\\,#2}","\\gr":"\\gamma","\\vec":"\\mathbf{#1}","\\tagl":"\\tag{#1}","\\eqref":"(#1)","\\laplacian":`\\mathbf{\\nabla ^2}`,"\\label":"{}","\\negadelta":`\\nabla`,"\\eqref":"\\href{###1}{(\\text{#1})}","\\ref":"\\href{###1}{\\text{#1}}","\\label":"\\htmlId{#1}{}"}})}</script><h1 id=what-happens-when-you-press-go>What Happens When You Press Go?
<a class=anchor href=#what-happens-when-you-press-go>#</a></h1><p>Following the sequence of events that take place in a WARPXM simulation by stepping through in the debugger has helped me to understand the code structure and concepts. I would highly recommend going so at least once. I have tried to explain what happens in plain English in the hopes that it will help me (and maybe someone else) to better understand how things are structured and what to expect when working with WARPXM.</p><h2 id=entrypoint>Entrypoint
<a class=anchor href=#entrypoint>#</a></h2><details><summary><code>warpxm.cc: int main(int argc, char** argv)</code></summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span><span style=color:#f92672>**</span> argv)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>warpxm_init(argc, argv)) { exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>); }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// run top level warpxm main
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    res <span style=color:#f92672>=</span> warpxm_main(argc, argv);
</span></span><span style=display:flex><span>    warpxm_finalize();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><p>There are just three calls, <code>warpxm_init()</code>, <code>warpxm_main()</code>, and <code>warpxm_finalize()</code>. We don&rsquo;t need to pay much attention to <code>warpxm_init</code>, since its purpose is just to initialize the MPI and PETSc frameworks. MPI is the message-passing framework that allows for massive parallelization. PETSc is a toolkit that helps us use MPI, parse command-line options, create meshes, and other things.</p><p><code>warpxm_main</code> is similarly high level:</p><details><summary><code>warpxm.cc: int warpxm_main(int argc, char** argv)</code></summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>warpxm_main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span><span style=color:#f92672>**</span> argv)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// create new WARPXM simulation using the command line args
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    WmSimulation sim;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Parse the input command
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>bool</span> res <span style=color:#f92672>=</span> sim.parseCmdLine();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (res) { <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Read in the input file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>ifstream inp(sim.getInpFileName().c_str());
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... error checking ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Convert input file to a string
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>string inputStr((std<span style=color:#f92672>::</span>istreambuf_iterator<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span>(inp)),
</span></span><span style=display:flex><span>                         std<span style=color:#f92672>::</span>istreambuf_iterator<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>    inp.seekg(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Store the input file in the simulation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    sim.setInputFileText(inputStr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// create cryptset for simulation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    WxCryptSet inputSet(inp);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Step one - setup the simulation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    sim.setup(inputSet);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Step two - run the simulation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    sim.simulate();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Step three - drink to your success
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><ul><li>Initialize our <code>WmSimulation</code> object. Nothing much happens when we init this other than creating a message-passing client (<code>WxMpiMsg</code>) and HDF5 i/o client (<code>WxHdf5Io</code>) that will be used to read/write data.</li><li>Parse the command-line options, simply reading the values of command-line flags.<ul><li><code>-input-file</code>/<code>-i</code> populates <code>inpFileName</code> with the input file contents, for parsing</li><li><code>-run-name</code>/<code>-n</code> populates <code>sim.runName</code></li><li><code>-restart-from-frame</code>/<code>-f</code> or <code>-restart-auto</code>/<code>-r</code> will populate <code>sim.restartFrame</code></li><li>If <code>-debug</code> was passed, the process waits for a debugger like <code>gdb</code> or <code>lldb</code> to attach to the process and allow things to continue.</li></ul></li><li>Turn the input file into a proper <code>WxCryptSet</code>, which is simply an immutable, nested map of name-value pairs where each name is a string and each value is a native-type object, array of native objects, or another nested <code>WxCrypt</code>. I like to think about <code>WxCryptSet</code> as a thread-safe place to look up values which are global across the whole sim and which do not ever change.<ul><li>This involves parsing the full text of the input file, as described in
<a href=https://faculty.washington.edu/shumlak/WARPX/html/warpxm_input.html>https://faculty.washington.edu/shumlak/WARPX/html/warpxm_input.html</a></li></ul></li><li>Then, we do <code>sim.setup</code> and <code>sim.simulate</code> which cover the entire simulation</li></ul><h2 id=setup>Setup
<a class=anchor href=#setup>#</a></h2><details><summary><code>wmsimulation.cc: void WmSimulation::setup(const WxCryptSet& wxc)</code></summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> WmSimulation<span style=color:#f92672>::</span>setup(<span style=color:#66d9ef>const</span> WxCryptSet<span style=color:#f92672>&amp;</span> wxc)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// determine run name
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (wxc.has(<span style=color:#e6db74>&#34;RunName&#34;</span>))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>string possibleRunName <span style=color:#f92672>=</span> wxc.get<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span>(<span style=color:#e6db74>&#34;RunName&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (possibleRunName[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;/&#39;</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// This is a filename from root
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            runName <span style=color:#f92672>=</span> possibleRunName;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// This is a filename in the current directory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            size_t trnc <span style=color:#f92672>=</span> inpFileName.find_last_of(<span style=color:#e6db74>&#34;/&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (trnc <span style=color:#f92672>!=</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>::</span>npos)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                runName <span style=color:#f92672>=</span> inpFileName.substr(<span style=color:#ae81ff>0</span>, trnc) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;/&#34;</span> <span style=color:#f92672>+</span> possibleRunName;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                runName <span style=color:#f92672>=</span> possibleRunName;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (runName <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        runName <span style=color:#f92672>=</span> stripName(inpFileName);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// create WarpX root logger
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    WxLogger<span style=color:#f92672>*</span> wr <span style=color:#f92672>=</span> WxLogger<span style=color:#f92672>::</span>get(<span style=color:#e6db74>&#34;warpx-root&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// set root logger&#39;s verbosity level
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>string level;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (wxc.has(<span style=color:#e6db74>&#34;GlobalVerbosity&#34;</span>))
</span></span><span style=display:flex><span>        level <span style=color:#f92672>=</span> wxc.get<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span>(<span style=color:#e6db74>&#34;GlobalVerbosity&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        level <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;debug&#34;</span>;
</span></span><span style=display:flex><span>    wr<span style=color:#f92672>-&gt;</span>setLevel(level);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// add file handler to root logger
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>ostringstream fn;
</span></span><span style=display:flex><span>    fn <span style=color:#f92672>&lt;&lt;</span> runName <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;_&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>getMsg().rank() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;.log&#34;</span>;
</span></span><span style=display:flex><span>    WxLogRecordHandler<span style=color:#f92672>*</span> wrfhndl <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> WxFileHandler(fn.str());
</span></span><span style=display:flex><span>    wr<span style=color:#f92672>-&gt;</span>addHandler(wrfhndl);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// create WarpX console logger
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    WxLogger<span style=color:#f92672>*</span> wrc <span style=color:#f92672>=</span> WxLogger<span style=color:#f92672>::</span>get(<span style=color:#e6db74>&#34;warpx-root.console&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// set console logger&#39;s verbosity level
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (wxc.has(<span style=color:#e6db74>&#34;Verbosity&#34;</span>))
</span></span><span style=display:flex><span>        level <span style=color:#f92672>=</span> wxc.get<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span>(<span style=color:#e6db74>&#34;Verbosity&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        level <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;debug&#34;</span>;
</span></span><span style=display:flex><span>    wrc<span style=color:#f92672>-&gt;</span>setLevel(level);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// add stream handler to console
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    WxLogRecordHandler<span style=color:#f92672>*</span> wrshndl <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> WxStreamHandler();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>getMsg().rank() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#75715e>// add console stream only on rank 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        wrc<span style=color:#f92672>-&gt;</span>addHandler(wrshndl);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// get output streams from newly created loggers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    WxLogStream debStrm <span style=color:#f92672>=</span> wrc<span style=color:#f92672>-&gt;</span>getDebugStream();
</span></span><span style=display:flex><span>    WxLogStream infoStrm <span style=color:#f92672>=</span> wrc<span style=color:#f92672>-&gt;</span>getInfoStream();
</span></span><span style=display:flex><span>    WxLogStream errStrm <span style=color:#f92672>=</span> wrc<span style=color:#f92672>-&gt;</span>getErrorStream();
</span></span><span style=display:flex><span>    WxLogStream wrnStrm <span style=color:#f92672>=</span> wrc<span style=color:#f92672>-&gt;</span>getWarningStream();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//////////////////////////////
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// now setup top level solver
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    debStrm <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Setting up WARPXM simulation...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string simName;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// name of simulation to run
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (wxc.has(<span style=color:#e6db74>&#34;Simulation&#34;</span>))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        simName <span style=color:#f92672>=</span> wxc.get<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span>(<span style=color:#e6db74>&#34;Simulation&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// no simulation specified, so throw exception
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        WxExcept <span style=color:#a6e22e>wxe</span>(<span style=color:#e6db74>&#34;No Simulation key found in &#34;</span>);
</span></span><span style=display:flex><span>        wxe <span style=color:#f92672>&lt;&lt;</span> inpFileName <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> wxe;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>wxc.hasSet(simName))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// solver not found
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        WxExcept <span style=color:#a6e22e>wxe</span>(<span style=color:#e6db74>&#34;ERROR: Solver set &#34;</span>);
</span></span><span style=display:flex><span>        wxe <span style=color:#f92672>&lt;&lt;</span> simName <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; not found&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> wxe;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// get hold of solver&#39;s cryptset
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> WxCryptSet<span style=color:#f92672>&amp;</span> solverCrypt <span style=color:#f92672>=</span> wxc.getSet(simName);
</span></span><span style=display:flex><span>    debStrm <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Simulation name is &#34;</span> <span style=color:#f92672>&lt;&lt;</span> simName <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// while the general class structure is setup to handle registration and WxCreator
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// process for getting new instances of WmSolverBase types
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// as is done elsewhere in the code for WmVariables, and WmHostActions, for example,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// we have not implemented this functionality because
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// there has only ever been one class implementation, WmSolver.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// To mimick the formatting at other levels of the crypt set, we at least check that
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// the Type and Kind fields match what they should be.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (solverCrypt.has(<span style=color:#e6db74>&#34;Type&#34;</span>))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>string solverTypeStr <span style=color:#f92672>=</span> solverCrypt.get<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span>(<span style=color:#e6db74>&#34;Type&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (solverTypeStr <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;WmSolverBase&#34;</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            WxExcept <span style=color:#a6e22e>wxe</span>(<span style=color:#e6db74>&#34;Unrecognized Type field in input file for Simulation &#34;</span>);
</span></span><span style=display:flex><span>            wxe <span style=color:#f92672>&lt;&lt;</span> simName <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;.  Only &#39;WmSolverBase&#39; currently supported.&#34;</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> wxe;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#a6e22e>WxExcept</span>(<span style=color:#e6db74>&#34;Simulation &#39;Type&#39; field missing in input file.&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (solverCrypt.has(<span style=color:#e6db74>&#34;Kind&#34;</span>))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>string solverKindStr <span style=color:#f92672>=</span> solverCrypt.get<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span>(<span style=color:#e6db74>&#34;Kind&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (solverKindStr <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;WmSolver&#34;</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            WxExcept <span style=color:#a6e22e>wxe</span>(<span style=color:#e6db74>&#34;Unrecognized Kind field in input file for Simulation &#34;</span>);
</span></span><span style=display:flex><span>            wxe <span style=color:#f92672>&lt;&lt;</span> simName <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;. Only &#39;WmSolver&#39; currently supported.&#34;</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> wxe;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#a6e22e>WxExcept</span>(<span style=color:#e6db74>&#34;Simulation &#39;Kind&#39; field missing in input file.&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// create new solver
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    solver <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> WmSolver(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// set I/O for use in solver
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    solver<span style=color:#f92672>-&gt;</span>setIo(<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>getIo());
</span></span><span style=display:flex><span>    <span style=color:#75715e>// set msg for use in solver
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    solver<span style=color:#f92672>-&gt;</span>setMsg(<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>getMsg());
</span></span><span style=display:flex><span>    <span style=color:#75715e>// setup solver
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    solver<span style=color:#f92672>-&gt;</span>setup(solverCrypt);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><p>A lot of things going on in <code>WmSimulation::setup</code>!</p><ul><li>Less important initialization: Ensure we have a <code>runName</code>, initialize the <code>WxLogger</code> loggers</li><li>Create a <code>WmSolver</code> and give it the same i/o and message clients as the <code>sim</code></li><li>Run <code>WmSolver.setup</code> with the <code>&lt;sim></code> node of the input file as input<ul><li>Sets the start and end times of the sim.</li><li>If the sim is being restarted (one of the restart command-line flags was passed), figure out the appropriate frame we should start at.</li><li>Set up the simulation domain</li><li>Create any variables defined in the input file</li><li>Initialize all host actions</li></ul></li></ul><h3 id=domain-setup>Domain Setup
<a class=anchor href=#domain-setup>#</a></h3><ul><li>Create a <code>WmDomain</code> object and run <code>WmDomain.setup</code><ul><li>Figure out how many different MPI processes are relevant, based on the <code>NumPartitions</code> field in the input file</li><li>Create a <code>mesh</code> from the <code>&lt;mesh></code> node of the input file<ul><li>If the sim is being restarted, look for the appropriate mesh <code>.h5</code> file in the working directory, and error if not found</li><li>Generate the appropriate type of mesh. This is usually a block mesh (<code>block_mesh</code>) which just contains equally-spaced cells, but can also be an arbitrary mesh.</li><li>Write the generated mesh definition to a file, e.g. <code>block_mesh_abd3712ea51f965c.inp</code></li><li>Break the mesh up into <code>WmUnstructuredPatch</code> patches so that it can be distributed across however many MPI processes we have.</li><li>Generate the appropriate geometry for each patch. For any local patches (patches which should be managed by the current MPI process), we generate the full mesh geometry as a <code>WmUnstructuredGeometry</code>, which is the basic structure we use to represent the geometric nodes for the mesh. Once the mesh is generated, we dump the mesh for each patch as an h5 file (<code>restartMesh...</code>) so that we may restart the simulation at a later time without needing to re-generate the geometry.</li><li>We use DG basis elements to represent the mesh, so we also export the basis decomposition for the patch domain as an h5 file (<code>plotMesh...</code>), so that it is possible to reconstruct the physical geometry for later plotting and analysis</li></ul></li></ul></li></ul><h3 id=variable-setup>Variable Setup
<a class=anchor href=#variable-setup>#</a></h3><ul><li>For each variable defined in the input file (everything of <code>Type = variable</code>) we initialize that variable setting its basis according the domain we computed above</li><li>For the hybrid kinetic solver, we additionally compute bases for the velocity space elements here.</li><li>Variables are not set to their initial values yet; that is done by a variable adjuster host action (<code>va_runner</code>) next</li></ul><h3 id=host-action-initialization>Host Action Initialization
<a class=anchor href=#host-action-initialization>#</a></h3><ul><li>Each host action (<code>Type = WmHostAction|host_action|subsolver</code>) gets setup and inserted into the hostActions map. Different types of host action have different setup steps and effects. There are
<a href=/r/img/research/warpxm/classdiagram-hostaction.png>a lot</a> of different types that directly extend <code>WmHostAction</code> in WARPXM, but the top-level ones relevant to most sims are:<ul><li><strong>Time Integrator</strong>: The time integrator that moves the state forward in time. This will almost always be the explicit Runge-Kutta temporal solver.</li><li><strong>Patch Processors</strong>: This coordinates patch processes across the domain. Patch processes are any process which can be evaluated locally within a single patch. For example, the spatial solver is a patch process which is called by the time integrator host action to compute \( \pdv{q}{t} \) (by implementing the nodal discontinuous Galerkin method). Variable adjusters which set/modify the value of variables across the domain are another common example, and are used to set initial conditions as we&rsquo;ll see later.</li><li><strong>Writers</strong>: Two types of writer: frame writers and diagnostic writers. A frame writer dumps the current variables to disk in HDF5 format each frame. The frame writer only needs to write the current data for the local patch, as opposed to diagnostic writers which are typically used to integrate variables across the global domain. Diagnostics can be <code>Probe</code>s (simply retrieve the current value of variables) or <code>WmIntegrator</code>s (integrate an expression over the domain or a subdomain). At pre-defined time intervals, the diagnostics writer evaluates each defined diagnostic and writes the result to a CSV file.</li><li><strong>Synchronizer</strong> When we require data that spans patches hosted on different MPI processes, an asynchronous process is required to manage the requesting and copying of that data.</li></ul></li></ul><h2 id=solve>Solve
<a class=anchor href=#solve>#</a></h2><p>This is where the real work happens, so we need to pay extra attention here</p><details><summary><code>wmsolver.cc: void WmSolver::solve()</code></summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> WmSolver<span style=color:#f92672>::</span>solve()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    WxLogger<span style=color:#f92672>*</span> log <span style=color:#f92672>=</span> WxLogger<span style=color:#f92672>::</span>get(<span style=color:#e6db74>&#34;warpx-root.console&#34;</span>);
</span></span><span style=display:flex><span>    WxLogStream infStrm <span style=color:#f92672>=</span> log<span style=color:#f92672>-&gt;</span>getInfoStream();
</span></span><span style=display:flex><span>    WxLogStream debStrm <span style=color:#f92672>=</span> log<span style=color:#f92672>-&gt;</span>getDebugStream();
</span></span><span style=display:flex><span>    WxLogStream errStrm <span style=color:#f92672>=</span> log<span style=color:#f92672>-&gt;</span>getErrorStream();
</span></span><span style=display:flex><span>    presolve();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    real frame_time <span style=color:#f92672>=</span> (_tend <span style=color:#f92672>-</span> _tstart) <span style=color:#f92672>/</span> _nout;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> start_time <span style=color:#f92672>=</span> getCurrentTime();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> start_frame <span style=color:#f92672>=</span> getCurrentFrame();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.start(wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>ROOT_TIMING_SCOPE);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (size_t i <span style=color:#f92672>=</span> getCurrentFrame(); i <span style=color:#f92672>&lt;</span> _nout; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> frame_stop_time <span style=color:#f92672>=</span> start_time <span style=color:#f92672>+</span> (i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> start_frame) <span style=color:#f92672>*</span> frame_time;
</span></span><span style=display:flex><span>        infStrm <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Advancing solution starting at time &#34;</span> <span style=color:#f92672>&lt;&lt;</span> getCurrentTime() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; to &#34;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>&lt;&lt;</span> frame_stop_time <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;...</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Instantiate a new timer and most restrictive timestep constraint
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        WxTimer advTimer;
</span></span><span style=display:flex><span>        TimestepConstraint most_restrictive_tc;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Perform frame advance, catch any exception.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        advTimer.startTimer();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            most_restrictive_tc <span style=color:#f92672>=</span> advance(frame_stop_time);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>catch</span> (WxExcept wxe)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            infStrm <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Exception caught, simulation exiting. See error log for details.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            errStrm <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>Exception caught in wxm::wmsolver::solve() at t = &#34;</span> <span style=color:#f92672>&lt;&lt;</span> getCurrentTime() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>            errStrm <span style=color:#f92672>&lt;&lt;</span> wxe.what() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>            exit(EXIT_FAILURE);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        advTimer.stopTimer();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Report on frame advance
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        infStrm <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Advanced from frame &#34;</span> <span style=color:#f92672>&lt;&lt;</span> getCurrentFrame() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; to &#34;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>&lt;&lt;</span> getCurrentFrame() <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; in &#34;</span> <span style=color:#f92672>&lt;&lt;</span> advTimer.timeElapsedAsString()
</span></span><span style=display:flex><span>                <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;. &#34;</span>;
</span></span><span style=display:flex><span>        infStrm <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Current dt = &#34;</span> <span style=color:#f92672>&lt;&lt;</span> getDt() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Report the most restrictive tc among each frame
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        infStrm <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Most restrictive timestep constraint this period was:</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>        infStrm <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>{dt = &#34;</span> <span style=color:#f92672>&lt;&lt;</span> most_restrictive_tc.getDt() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;physics = &#39;&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>most_restrictive_tc.getPhysics() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;&#39;, &#34;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;x = (&#34;</span> <span style=color:#f92672>&lt;&lt;</span> most_restrictive_tc.getX()[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>&lt;&lt;</span> most_restrictive_tc.getX()[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>&lt;&lt;</span> most_restrictive_tc.getX()[<span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span>                <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;)}</span><span style=color:#ae81ff>\n\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Walltime report in the debug stream
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.print_timings(debStrm);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        incrementCurrentFrame();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// upon completing the all specified simulation, run EndOnly steps
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    debStrm <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>Running EndOnly steps...</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    endOnly();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Walltime report
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.print_timings(infStrm);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><h3 id=pre-solve-actions>Pre-solve Actions
<a class=anchor href=#pre-solve-actions>#</a></h3><ul><li>First, we run through the <code>presolve</code> steps:<details><summary><code>wmsolver.cc: void WmSolver::presolve()</code></summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>void</span> WmSolver<span style=color:#f92672>::</span>presolve()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// fetch stream for logging messages
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    WxLogger<span style=color:#f92672>*</span> log <span style=color:#f92672>=</span> WxLogger<span style=color:#f92672>::</span>get(<span style=color:#e6db74>&#34;warpx-root.console&#34;</span>);
</span></span><span style=display:flex><span>    WxLogStream infStrm <span style=color:#f92672>=</span> log<span style=color:#f92672>-&gt;</span>getInfoStream();
</span></span><span style=display:flex><span>    WxLogStream debStrm <span style=color:#f92672>=</span> log<span style=color:#f92672>-&gt;</span>getDebugStream();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>bool</span> fromRestart <span style=color:#f92672>=</span> (getCurrentFrame() <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// initialize hostactions
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> ha : _hostActions)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        ha.second<span style=color:#f92672>-&gt;</span>init();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// initialize subsolvers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> ss : _subSolvers)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        ss.second<span style=color:#f92672>-&gt;</span>init();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Run the initialization steps
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (fromRestart)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// run startOnly subsolvers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        debStrm <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Running Restart steps...</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        restart();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// run startOnly subsolvers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        debStrm <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Running StartOnly steps...</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        startOnly();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><ul><li>Call the optional <code>init()</code> function for each defined host action and sub-solver</li><li>Then, we perform a single <code>ha->step()</code> for each host action in the sim&rsquo;s <code>start_only_group</code> list. Per the definition in the parent <code>WxStepper</code> class, the <code>step()</code> method for a host action must advance the state of the object by the assigned time step dt, getDt(). This is where we set the initial conditions for each defined variable. In warpy, these are defined by supplying a list of variable adjusters to the <code>initial_conditions</code> parameter of a <code>warpy.dg_sim</code> object.<ul><li>For a <code>va_runner</code> host action, <code>step()</code> means:<ul><li>For each variable adjuster in the host action, call <code>va->solve(time, variables_)</code> to update <code>variables_</code> as appropriate for the current time. In doing so, we need to look up the local patch arrays for the variables being adjusted, loading the physical geometry (e.g. <code>(x,y,z)</code>, <code>(dx, dy, dz)</code>) from the basis for element in the patch, and evaluating each <code>WmApplication</code> in the application list for this variable adjuster on each element in the patch.</li></ul></li></ul></li></ul></li></ul><h3 id=main-loop>Main Loop
<a class=anchor href=#main-loop>#</a></h3><ul><li>In the main loop, we try to advance the solution from the current frame (0 at the start) to the next frame until we reach the end of the time interval by repeatedly calling <code>WmSolver::advance()</code>.<details><summary><code>wmsolver.cc: TimestepConstraint WmSolver::advance()</code></summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>
</span></span><span style=display:flex><span>TimestepConstraint WmSolver<span style=color:#f92672>::</span>advance(real tend)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    WxLogger<span style=color:#f92672>*</span> log <span style=color:#f92672>=</span> WxLogger<span style=color:#f92672>::</span>get(<span style=color:#e6db74>&#34;warpx-root.console&#34;</span>);
</span></span><span style=display:flex><span>    WxLogStream debStrm <span style=color:#f92672>=</span> log<span style=color:#f92672>-&gt;</span>getDebugStream();
</span></span><span style=display:flex><span>    WxLogStream infStrm <span style=color:#f92672>=</span> log<span style=color:#f92672>-&gt;</span>getInfoStream();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> nstep <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> tstart <span style=color:#f92672>=</span> getCurrentTime();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// This says to not set the timestep below this limit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> real limit_dt <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>max(std<span style=color:#f92672>::</span>fabs(tend), std<span style=color:#f92672>::</span>fabs(tstart)) <span style=color:#f92672>*</span> <span style=color:#ae81ff>100.0</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>                          std<span style=color:#f92672>::</span>numeric_limits<span style=color:#f92672>&lt;</span>real<span style=color:#f92672>&gt;::</span>epsilon();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> real limit_t <span style=color:#f92672>=</span> tend <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>5</span> <span style=color:#f92672>*</span> std<span style=color:#f92672>::</span>numeric_limits<span style=color:#f92672>&lt;</span>real<span style=color:#f92672>&gt;::</span>epsilon());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    WxMsgBase<span style=color:#f92672>&amp;</span> msg <span style=color:#f92672>=</span> getMsg();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    TimestepConstraint most_restrictive_tc <span style=color:#f92672>=</span> TimestepConstraint();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// loop advancing solution using adaptive time-stepping
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span> (getCurrentTime() <span style=color:#f92672>&lt;</span> limit_t)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> t <span style=color:#f92672>=</span> getCurrentTime();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> dt <span style=color:#f92672>=</span> getDt();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>flexible_writeout)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            dt <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>min<span style=color:#f92672>&lt;</span>real<span style=color:#f92672>&gt;</span>(dt, limit_t <span style=color:#f92672>-</span> t);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Instantiate new iterations total and timestep constraint
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> iters;
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>TimestepConstraint<span style=color:#f92672>&gt;</span> tc;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Take time step
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>auto</span> tmp <span style=color:#f92672>=</span> step_dt(dt, limit_dt);
</span></span><span style=display:flex><span>        iters <span style=color:#f92672>=</span> tmp.first;
</span></span><span style=display:flex><span>        tc <span style=color:#f92672>=</span> tmp.second.get_tc();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Let user know that the step has ended
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        debStrm <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; Ending Step &#34;</span> <span style=color:#f92672>&lt;&lt;</span> nstep <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; after &#34;</span> <span style=color:#f92672>&lt;&lt;</span> iters <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; attempts for t = &#34;</span> <span style=color:#f92672>&lt;&lt;</span> t <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; -&gt; &#34;</span> <span style=color:#f92672>&lt;&lt;</span> getCurrentTime()
</span></span><span style=display:flex><span>                <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; using dt = &#34;</span> <span style=color:#f92672>&lt;&lt;</span> tc<span style=color:#f92672>-&gt;</span>getDt() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Report the physics and location that restrict the time step dt
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        debStrm <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74> tc = {dt = &#34;</span> <span style=color:#f92672>&lt;&lt;</span> tc<span style=color:#f92672>-&gt;</span>getDt() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;physics = &#39;&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>(tc<span style=color:#f92672>-&gt;</span>getPhysics()) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;x = (&#34;</span> <span style=color:#f92672>&lt;&lt;</span> tc<span style=color:#f92672>-&gt;</span>getX()[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>&lt;&lt;</span> tc<span style=color:#f92672>-&gt;</span>getX()[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>&lt;&lt;</span> tc<span style=color:#f92672>-&gt;</span>getX()[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;)}</span><span style=color:#ae81ff>\n\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        setDt(tc<span style=color:#f92672>-&gt;</span>getDt());
</span></span><span style=display:flex><span>        most_restrictive_tc <span style=color:#f92672>=</span> TimestepConstraint<span style=color:#f92672>::</span>minDt(<span style=color:#f92672>*</span>tc, most_restrictive_tc);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>++</span>nstep;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> most_restrictive_tc;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><ul><li>On the first step, the solver attempts to advance time by the <code>dt_controller</code>&rsquo;s initial <code>dt</code>. Subsequent steps may try to advance by a larger or smaller <code>dt</code> if the <code>dt_controller</code> provided in the input file is not a <code>time_stepper.fixed_dt</code>.</li><li>For each host action in the per-step group, we tick forward with <code>host_action->step()</code><ul><li><p>We can peek at <code>tools/warpy/dg_sim.py</code> to see what host actions should be the per-step group for a DG sim. With some abbreviation, we see:<details><summary><code>tools/warpy/dg_sim.py: dg_sim.__init__()</code></summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># w_group is the group of writer host actions provided in the warpy input file</span>
</span></span><span style=display:flex><span>w_group <span style=color:#f92672>=</span> solver_sequence<span style=color:#f92672>.</span>sequence_group(name<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;write_group&#39;</span>, actions<span style=color:#f92672>=</span>writers)
</span></span><span style=display:flex><span><span style=color:#75715e># ps_group contains the temporal solvers provided in the warpy input file,</span>
</span></span><span style=display:flex><span><span style=color:#75715e># sandwiched between any optional pre- or post-time-integration actions</span>
</span></span><span style=display:flex><span>ps_group <span style=color:#f92672>=</span> solver_sequence<span style=color:#f92672>.</span>sequence_group(
</span></span><span style=display:flex><span>  name<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;perstep_group&#39;</span>, 
</span></span><span style=display:flex><span>  actions<span style=color:#f92672>=</span>pre_ti_host_actions <span style=color:#f92672>+</span> temporal_solvers <span style=color:#f92672>+</span> post_ti_host_actions
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#75715e># swap_group</span>
</span></span><span style=display:flex><span>swapper <span style=color:#f92672>=</span> host_actions<span style=color:#f92672>.</span>swapper(
</span></span><span style=display:flex><span>  name<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;swapper&#39;</span>,
</span></span><span style=display:flex><span>  srcs<span style=color:#f92672>=</span>[v<span style=color:#f92672>.</span>name(<span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>for</span> v <span style=color:#f92672>in</span> evolve_vars],
</span></span><span style=display:flex><span>  dsts<span style=color:#f92672>=</span>[v<span style=color:#f92672>.</span>name(v<span style=color:#f92672>.</span>output_stage <span style=color:#66d9ef>if</span> (hasattr(v, <span style=color:#e6db74>&#39;output_stage&#39;</span>)) <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>None</span>) <span style=color:#66d9ef>for</span> v <span style=color:#f92672>in</span> evolve_vars]
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>swap_group <span style=color:#f92672>=</span> solver_sequence<span style=color:#f92672>.</span>sequence_group(name<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;swap_group&#39;</span>, actions<span style=color:#f92672>=</span>[swapper])
</span></span><span style=display:flex><span><span style=color:#75715e># So per-step host actions are the writers, followed by the temporal solvers, followed by swappers</span>
</span></span><span style=display:flex><span>ps_step <span style=color:#f92672>=</span> [w_group, ps_group, swap_group]
</span></span><span style=display:flex><span>ss <span style=color:#f92672>=</span> solver_sequence<span style=color:#f92672>.</span>solver_sequence(
</span></span><span style=display:flex><span>  start_only<span style=color:#f92672>=</span>so_step,
</span></span><span style=display:flex><span>  per_step<span style=color:#f92672>=</span>ps_step,
</span></span><span style=display:flex><span>  per_redo_per_step<span style=color:#f92672>=</span>r_step,
</span></span><span style=display:flex><span>  end_only<span style=color:#f92672>=</span>eo_step,
</span></span><span style=display:flex><span>  restart<span style=color:#f92672>=</span>res_step
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>super(dg_sim, self)<span style=color:#f92672>.</span>__init__(solver_sequence<span style=color:#f92672>=</span>ss, <span style=color:#f92672>...</span>)
</span></span></code></pre></div></div></details></p></li><li><p>The big one is of course the temporal solver. For pretty much everything we&rsquo;re using WARPXM for, that&rsquo;s going to be a <code>Kind = explicit_runge_kutta</code> host action (the implicit solver still exists but is rarely used), which maps to a <code>WmTemporalSolver_RK</code>.</p><details><summary><code>src/dfem/temporal_solvers/wmtemporalsolver_rk.h: WxStepperStatus WmTemporalSolver_RK::step()</code></summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>WxStepperStatus WmTemporalSolver_RK<span style=color:#f92672>::</span>step()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.start(<span style=color:#e6db74>&#34;rk_solver/step&#34;</span>);
</span></span><span style=display:flex><span>    time_t time <span style=color:#f92672>=</span> getCurrentTime();
</span></span><span style=display:flex><span>    time_t dt <span style=color:#f92672>=</span> getDt();
</span></span><span style=display:flex><span>	std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>TimestepConstraint<span style=color:#f92672>&gt;</span> sugg_tc <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>make_shared<span style=color:#f92672>&lt;</span>TimestepConstraint<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> rk_stage <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; rk_stage <span style=color:#f92672>&lt;</span> scheme_<span style=color:#f92672>-&gt;</span>getNumStages(); rk_stage<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> real current_time <span style=color:#f92672>=</span> time <span style=color:#f92672>+</span> scheme_<span style=color:#f92672>-&gt;</span>getTimeUpdate(rk_stage) <span style=color:#f92672>*</span> dt;
</span></span><span style=display:flex><span>        variables_type<span style=color:#f92672>&amp;</span> q_n <span style=color:#f92672>=</span> variables_[rk_stage];
</span></span><span style=display:flex><span>        variables_type<span style=color:#f92672>&amp;</span> q_p <span style=color:#f92672>=</span> variables_[rk_stage <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// zero out q_p which are temporal vars
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        fill_local(rk_stage <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// TODO: this is only here until zero_fluxes is implemented with scopes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> ss : spatial_solvers_)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            ss<span style=color:#f92672>-&gt;</span>zero_fluxes();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// run all variable adjusters
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        {
</span></span><span style=display:flex><span>            size_t idx <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (size_t i <span style=color:#f92672>=</span> min_priority; i <span style=color:#f92672>&lt;=</span> max_priority; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (idx <span style=color:#f92672>&lt;</span> va_priorities.size() <span style=color:#f92672>&amp;&amp;</span> va_priorities[idx] <span style=color:#f92672>&lt;=</span> i)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    adjusters_[idx]<span style=color:#f92672>-&gt;</span>solve(current_time, q_n);
</span></span><span style=display:flex><span>                    adjusters_[idx]<span style=color:#f92672>-&gt;</span>Barrier(getMsg(), current_time, q_n);
</span></span><span style=display:flex><span>                    <span style=color:#f92672>++</span>idx;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.start(<span style=color:#e6db74>&#34;rk_sync&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Initiate syncing on every MPI rank
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                start_sync(rk_stage);
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Wait for syncing to finish
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                finish_sync(rk_stage);
</span></span><span style=display:flex><span>                wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.stop();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// run the spatial solvers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> ss : spatial_solvers_)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>			std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>TimestepConstraint<span style=color:#f92672>&gt;</span> tc <span style=color:#f92672>=</span> ss<span style=color:#f92672>-&gt;</span>solve(current_time, q_n, q_p);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Comparing spatial_solver&#39;s suggested time step with current minimum suggested time step. 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// Updating sugg_tc if new minimum
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#f92672>*</span>sugg_tc <span style=color:#f92672>=</span> TimestepConstraint<span style=color:#f92672>::</span>minDt(<span style=color:#f92672>*</span>sugg_tc, <span style=color:#f92672>*</span>tc);
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            ss<span style=color:#f92672>-&gt;</span>Barrier(getMsg(), current_time, q_p);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// rhs is now in q_p; need to accumulate with previous q&#39;s to get actual q_p
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        scheme_<span style=color:#f92672>-&gt;</span>calc_stage(rk_stage, temporal_vars_, variables_, dt);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.start(<span style=color:#e6db74>&#34;rk_sync&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Initiate syncing on every MPI rank
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        start_sync(rk_stage <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Wait for syncing to finish
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        finish_sync(rk_stage <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.stop();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    wxm<span style=color:#f92672>::</span>timer<span style=color:#f92672>::</span>TIMER.stop(); <span style=color:#75715e>// for &#34;rk_solver/step&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// TODO: how to get time step limit to take into account sources/diffusion/advection?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>WxStepperStatus</span>(dt <span style=color:#f92672>&lt;=</span> sugg_tc<span style=color:#f92672>-&gt;</span>getDt(), sugg_tc);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details></li></ul></li></ul></li></ul><p>The Runge-Kutta temporal solver has multiple stages, depending on the temporal order specified in the input file. For each stage:</p><ul><li>Run any variable adjusters associated with the temporal solver. In the case of the <code>advection.py</code> example, we use a shock-capturing limiter (<code>warpy.variable_adjusters.limiters.dg_moe_rossmanith</code>) which enforces local bounds on variables by damping the high-order corrections.</li><li>The DG spatial solver comes next, and this is where the really heavy lifting happens. The actual flux calculations are up to the <code>WmApplication</code>(s) that we&rsquo;ve defined in our input file. To express the physics of the problem in the language of DG, an application can define:<ul><li><code>numerical_flux()</code>: Compute boundary flux over the surface of a DG element</li><li><code>internal_flux()</code>: Compute volume flux within a DG element</li><li><code>source()</code>: Contribute a source/sink term</li><li><code>bc_q()</code>: Set the value of &ldquo;ghost&rdquo; nodes on the domain boundary</li><li><code>bcNumericalFlux()</code>: Conpute boundary flux for element faces on the domain boundary</li></ul></li></ul><p>I don&rsquo;t pretend to fully understand the DG implementation in WARPXM just yet, so I may get some things slightly wrong here. As far as I can tell, the calculation of $\pdv{q}{t}$ has been intentionally broken up into a few phases: <code>in_kernel</code>, <code>ex_kernel</code>, and <code>rhs_kernel</code></p><ol><li><code>in_kernel</code>: Compute the internal flux within each DG element<ul><li>If there are apps with sources that require computing Gaussian quadrature, we compute those quadrature points and call <code>app->source()</code> to allow the app to do its thing and compute the source flux on the element.</li><li>After loading the variables and node geometry for the current patch, the internal flux computation is all up to the application when we call <code>app->internal_flux()</code> for each app to compute the internal flux on the element.</li></ul></li><li><code>ex_kernel</code>: Compute the flux across each face of the element. For each app we call <code>app->numerical_flux()</code> to get the flux for each element face. Then, for the boundary conditions, we collect the set of boundary faces in the patch and for each one we find applications that supply a <code>bcNumericalFlux()</code> function and call it, summing up the results.</li><li><code>rhs_kernel</code>: This is basically just combining the individual terms together into the right-hand-side of eq. 3.3.21 from Iman&rsquo;s dissertation:
<span>\[\pdv{}{t} q_{ij} ^ \lambda = J_{ml} ^\lambda \Upsilon _{jlk} f^ \lambda _{imk} - \sum_{\gamma \in \tilde{\Gamma} _\lambda} G_{\lambda \gamma} \Xi _{jk} ^{\lambda \gamma} F_{ik} ^{\lambda \gamma} + \Psi _{jk} s_{ik} ^{\lambda}\]
</span><script>function loadKatex(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}],throwOnError:!1,trust:e=>["\\htmlId","\\href"].includes(e.command),macros:{"\\lcm":"\\mathop{\\mathrm{lcm}}","\\sen":"\\text{sen}\\,","\\dd":"\\mathop{\\mathrm{d} #1}","\\abs":`\\lvert #1 \\rvert`,"\\dd":"\\text{d}","\\cross":"\\times","\\pdv":"\\frac{\\partial #1}{\\partial #2}","\\curl":`\\nabla \\cross #1`,"\\vu":"\\mathbf{\\hat{#1}}","\\vdot":"\\dot","\\div":`\\nabla \\cdot #1`,"\\grad":`\\nabla`,"\\dv":"\\frac{d\\,#1}{d\\,#2}","\\gr":"\\gamma","\\vec":"\\mathbf{#1}","\\tagl":"\\tag{#1}","\\eqref":"(#1)","\\laplacian":`\\mathbf{\\nabla ^2}`,"\\label":"{}","\\negadelta":`\\nabla`,"\\eqref":"\\href{###1}{(\\text{#1})}","\\ref":"\\href{###1}{\\text{#1}}","\\label":"\\htmlId{#1}{}"}})}</script>where $f^\lambda _{imk}$ is the internal flux computed above, $F _{ik} ^{\lambda \gamma}$ is the external flux computed above, $s _ {ik} ^{\lambda}$ is the source flux, and $ J _ {ml} ^\lambda \Upsilon _ {jlk} $, $ G _ {\lambda \gamma} \Xi _ {jk} ^{\lambda \gamma}$, and $\Psi _ {jk}$ are computed directly from the geometry and nodal basis for each element.</li></ol><ul><li><p>Each of these flux calculations and patch processes results may produce a timestep constraint, which gives the minimum allowable <code>dt</code> for the next step based on e.g. CFL condition. We always take the smallest constraint before moving forward.</p></li><li><p>Finally, once we&rsquo;ve (hopefully) stepped all the way to the final frame, each host action in the end-only-group (typically just the writers) gets a <code>step()</code> to write out the final frame&rsquo;s data, and the sim is done!</p></li></ul><h3 id=patch-processes>Patch Processes
<a class=anchor href=#patch-processes>#</a></h3><p>Class diagrams generated by Doxygen showing all the different implementations of patch processes we&rsquo;ve currently got:</p><p align=center><img alt=img/research/warpxm/classdiagram-WmPatchProcess.png src=/r/img/research/warpxm/classdiagram-WmPatchProcess.png></p><p align=center><img alt=img/research/warpxm/classdiagram-variable_adjuster_t.png src=/r/img/research/warpxm/classdiagram-variable_adjuster_t.png></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/Peppyhare/r/commit/9652a65324ccbe4b2a4351d50d57328064898f88 title='Last modified by Evan Bluhm | December 14, 2023' target=_blank rel=noopener><img src=/r/svg/calendar.svg class=book-icon alt=Calendar>
<span>December 14, 2023</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#what-happens-when-you-press-go>What Happens When You Press Go?</a><ul><li><a href=#entrypoint>Entrypoint</a></li><li><a href=#setup>Setup</a><ul><li><a href=#domain-setup>Domain Setup</a></li><li><a href=#variable-setup>Variable Setup</a></li><li><a href=#host-action-initialization>Host Action Initialization</a></li></ul></li><li><a href=#solve>Solve</a><ul><li><a href=#pre-solve-actions>Pre-solve Actions</a></li><li><a href=#main-loop>Main Loop</a></li><li><a href=#patch-processes>Patch Processes</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>