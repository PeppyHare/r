<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="


  \[\]




  What Happens When You Press Go?
  #

Following the sequence of events that take place in a WARPXM simulation by stepping through in the debugger has helped me to understand the code structure and concepts. I would highly recommend going through the process at least once. I have tried to explain what happens in plain English in the hopes that it will help me (and maybe someone else) to better understand how things are structured and what to expect when working with WARPXM."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://peppyhare.github.io/r/notes/research/warpxm-102/"><meta property="og:site_name" content="My Notes"><meta property="og:title" content="WARPXM 102 - Code Structure"><meta property="og:description" content="\[\] What Happens When You Press Go? # Following the sequence of events that take place in a WARPXM simulation by stepping through in the debugger has helped me to understand the code structure and concepts. I would highly recommend going through the process at least once. I have tried to explain what happens in plain English in the hopes that it will help me (and maybe someone else) to better understand how things are structured and what to expect when working with WARPXM."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta property="article:modified_time" content="2025-02-11T21:38:46-08:00"><title>WARPXM 102 - Code Structure | My Notes</title>
<link rel=icon href=/r/favicon.png><link rel=manifest href=/r/manifest.json><link rel=canonical href=https://peppyhare.github.io/r/notes/research/warpxm-102/><link rel=stylesheet href=/r/book.min.a9f8198cc4e08a8c08b25f83e2006e5e66c64d3d34b7046b3e8712b7980c6821.css integrity="sha256-qfgZjMTgiowIsl+D4gBuXmbGTT00twRrPocSt5gMaCE=" crossorigin=anonymous><script defer src=/r/fuse.min.js></script><script defer src=/r/en.search.min.e4226876ad0900fd66c5c80a68aec166cbcb00bdcaa662bb5f17c0d2581bd83d.js integrity="sha256-5CJodq0JAP1mxcgKaK7BZsvLAL3KpmK7XxfA0lgb2D0=" crossorigin=anonymous></script><script defer src=/r/sw.min.9e3a83f0b071ebe0141a16a33db93faadb2bdf712473a218febeed35ed243c08.js integrity="sha256-njqD8LBx6+AUGhajPbk/qtsr33Ekc6IY/r7tNe0kPAg=" crossorigin=anonymous></script><link rel=preload href=/r/katex/fonts/KaTeX_Main-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/r/katex/fonts/KaTeX_Main-Bold.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/r/katex/fonts/KaTeX_Main-Italic.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/r/katex/fonts/KaTeX_Math-Italic.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/r/katex/fonts/KaTeX_Size2-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/r/katex/fonts/KaTeX_Size3-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/r/fonts/roboto-v27-latin-regular.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/r/fonts/roboto-v27-latin-700.woff2 as=font type=font/woff2 crossorigin=anonymous></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/r/><span>My Notes</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/r/svg/translate.svg class=book-icon alt=Languages>
English</a></label><ul></ul></li></ul><ul><li class=book-section-flat><ul><li class=book-section-flat><input type=checkbox id=section-f04c181c9b16a37431fe06303d58b7a0 class=toggle>
<label for=section-f04c181c9b16a37431fe06303d58b7a0 class="flex justify-between"><a href=/r/notes/UWAA545/ class="navbutton
book-collapse-section">Computational Methods For Plasmas</a></label><ul><li><a href=/r/notes/UWAA545/01-syllabus/ class=navbutton>Syllabus</a></li><li><a href=/r/notes/UWAA545/02-plasma-models/ class=navbutton>Plasma Models</a></li><li><a href=/r/notes/UWAA545/03-pic-method/ class=navbutton>Particle in Cell Model</a></li><li><a href=/r/notes/UWAA545/04-pic-example/ class=navbutton>PIC - Example Implementation</a></li><li><a href=/r/notes/UWAA545/05-electrodynamic-pic/ class=navbutton>Multidimensional Electrodynamic PIC</a></li><li><a href=/r/notes/UWAA545/06-fluid-models/ class=navbutton>Fluid Models for Plasmas</a></li><li><a href=/r/notes/UWAA545/07-finite-difference-models/ class=navbutton>Finite Difference Methods for MHD</a></li><li><a href=/r/notes/UWAA545/08-mhd-equilibrium/ class=navbutton>MHD Equilibrium Calculations</a></li><li><a href=/r/notes/UWAA545/formulary/ class=navbutton>Formulary</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-b6bdf3598cf4214623cd2f8ff7b6e0f2 class=toggle>
<label for=section-b6bdf3598cf4214623cd2f8ff7b6e0f2 class="flex justify-between"><a href=/r/notes/UWAA560/ class="navbutton
book-collapse-section">Plasma Diagnostics</a></label><ul><li><a href=/r/notes/UWAA560/01-syllabus/ class=navbutton>Syllabus</a></li><li><a href=/r/notes/UWAA560/02-diagnostic-considerations/ class=navbutton>General Diagnostic Considerations</a></li><li><a href=/r/notes/UWAA560/03-magnetic-field-diagnostics/ class=navbutton>Magnetic Field Diagnostics</a></li><li><a href=/r/notes/UWAA560/04-electrostatic-diagnostics/ class=navbutton>Electrostatic Diagnostics</a></li><li><a href=/r/notes/UWAA560/05-index-of-refraction-measurements/ class=navbutton>Index of Refraction Measurements</a></li><li><a href=/r/notes/UWAA560/06-spectroscopic-measurements/ class=navbutton>Spectroscopic Measurements</a></li><li><a href=/r/notes/UWAA560/90-student-lectures/ class=navbutton>Student Lectures</a></li><li><a href=/r/notes/UWAA560/91-zeeman-spectroscopy/ class=navbutton>My class lecture</a></li><li><a href=/r/notes/UWAA560/formulary/ class=navbutton>Formulary</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-5b051410be8cdb0f46ad32fc2ad5a20d class=toggle>
<label for=section-5b051410be8cdb0f46ad32fc2ad5a20d class="flex justify-between"><a href=/r/notes/UWAA558/ class="navbutton
book-collapse-section">MHD Theory</a></label><ul><li><a href=/r/notes/UWAA558/01-syllabus/ class=navbutton>Syllabus</a></li><li><a href=/r/notes/UWAA558/02-plasma-models/ class=navbutton>Plasma Models</a></li><li><a href=/r/notes/UWAA558/03-plasma-fluid-model/ class=navbutton>Plasma Fluid Model</a></li><li><a href=/r/notes/UWAA558/04-two-fluid-plasma-model/ class=navbutton>Two-Fluid Plasma Model</a></li><li><a href=/r/notes/UWAA558/05-mhd-model/ class=navbutton>Magnetohydrodynamic (MHD) Model</a></li><li><a href=/r/notes/UWAA558/06-boundary-conditions/ class=navbutton>Boundary Conditions</a></li><li><a href=/r/notes/UWAA558/07-equilibrium-for-fusion/ class=navbutton>Equilibrium for Fusion</a></li><li><a href=/r/notes/UWAA558/08-1d-equilibria/ class=navbutton>1-D Equilibria</a></li><li><a href=/r/notes/UWAA558/09-2d-equilibria/ class=navbutton>2D Equilibria</a></li><li><a href=/r/notes/UWAA558/10-equilibrium-of-3d-configurations/ class=navbutton>Equilibrium of 3D Configurations</a></li><li><a href=/r/notes/UWAA558/11-mhd-stability/ class=navbutton>MHD Stability</a></li><li><a href=/r/notes/UWAA558/formulary/ class=navbutton>Formulary</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-c3201a1057283cb12ab09a42fe89bfb2 class=toggle checked>
<label for=section-c3201a1057283cb12ab09a42fe89bfb2 class="flex justify-between"><a href=/r/notes/research/ class="navbutton
book-collapse-section">Research Notes</a></label><ul><li><a href=/r/notes/research/dgh-datta/ class=navbutton>Electrodynamic Dory-Guest-Harris Instability</a></li><li><a href=/r/notes/research/warpxm-101/ class=navbutton>WARPXM 101 - Getting Started</a></li><li><a href=/r/notes/research/warpxm-102/ class="active navbutton">WARPXM 102 - Code Structure</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-34991d35561e8d266d64d5d323e97c7a class=toggle>
<label for=section-34991d35561e8d266d64d5d323e97c7a class="flex justify-between"><a href=/r/notes/UWAA557/ class="navbutton
book-collapse-section">Physics of Fusion Plasmas</a></label><ul><li><a href=/r/notes/UWAA557/ch10-0/ class=navbutton>Rules of thumb</a></li><li><a href=/r/notes/UWAA557/ch10-1/ class=navbutton>Statistical Mechanics</a></li><li><a href=/r/notes/UWAA557/ch10-2/ class=navbutton>Review of E&amp;M</a></li><li><a href=/r/notes/UWAA557/ch10-3/ class=navbutton>Lagrange Multipliers</a></li><li><a href=/r/notes/UWAA557/ch11-1/ class=navbutton>Wall-supported Plasma</a></li><li><a href=/r/notes/UWAA557/ch11-2/ class=navbutton>Collisions</a></li><li><a href=/r/notes/UWAA557/ch11-3/ class=navbutton>Oscillations</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-7c7b4e4d4494a744744faedd969cb670 class=toggle>
<label for=section-7c7b4e4d4494a744744faedd969cb670 class="flex justify-between"><a href=/r/notes/UWAA543/ class="navbutton
book-collapse-section">Computational CFD</a></label><ul><li><a href=/r/notes/UWAA543/ch20-1/ class=navbutton>Introduction to Computational CFD</a></li><li><a href=/r/notes/UWAA543/ch20-2/ class=navbutton>Governing Equations</a></li><li><a href=/r/notes/UWAA543/ch20-3/ class=navbutton>Reduced Models</a></li><li><a href=/r/notes/UWAA543/ch20-4/ class=navbutton>Equation Types</a></li><li><a href=/r/notes/UWAA543/ch20-5/ class=navbutton>Panel Method</a></li><li><a href=/r/notes/UWAA543/ch21-1/ class=navbutton>Finite Difference Algorithms</a></li><li><a href=/r/notes/UWAA543/ch21-2/ class=navbutton>Explicit Finite Difference Algorithms</a></li><li><a href=/r/notes/UWAA543/ch21-3/ class=navbutton>Finite Difference and Finite Volume Methods</a></li><li><a href=/r/notes/UWAA543/ch21-4/ class=navbutton>Implicit Algorithms</a></li><li><a href=/r/notes/UWAA543/ch21-5/ class=navbutton>Numerical Boundary Conditions</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-e5f141895443fc824f58730f7904d483 class=toggle>
<label for=section-e5f141895443fc824f58730f7904d483 class="flex justify-between"><a href=/r/notes/UWAA556/ class="navbutton
book-collapse-section">Plasma Waves</a></label><ul><li><a href=/r/notes/UWAA556/ch01-1/ class=navbutton>Mathematical review</a></li><li><a href=/r/notes/UWAA556/ch02-1/ class=navbutton>Plasma Waves in General Dielectric Media</a></li><li><a href=/r/notes/UWAA556/ch02-2/ class=navbutton>Wave Properties in Cold Unmagnetized Plasma</a></li><li><a href=/r/notes/UWAA556/ch02-3/ class=navbutton>Cold Magnetized Plasma Dispersion Relation</a></li><li><a href=/r/notes/UWAA556/ch02-4/ class=navbutton>The CMA Diagram</a></li><li><a href=/r/notes/UWAA556/ch03-1/ class=navbutton>Introduction to Kinetic Theory</a></li><li><a href=/r/notes/UWAA556/ch03-2/ class=navbutton>Landau Damping</a></li><li><a href=/r/notes/UWAA556/ch03-3/ class=navbutton>Waves in Hot Magnetized Plasma</a></li><li><a href=/r/notes/UWAA556/ch04-1/ class=navbutton>Fluid stuff</a></li><li><a href=/r/notes/UWAA556/ch04-2/ class=navbutton>Quasi-Linear Theory</a></li><li><a href=/r/notes/UWAA556/ch05-1/ class=navbutton>Diffusion and Resistivity</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-3a2759a8b11b3422da800ed19897932a class=toggle>
<label for=section-3a2759a8b11b3422da800ed19897932a class="flex justify-between"><a href=/r/notes/problems/ class="navbutton
book-collapse-section">Worked Problems</a></label><ul><li><a href=/r/notes/problems/gurnett/ch02/ class=navbutton>Characteristic Parameters of a Plasma</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-05ac7760b68f0e0530d0e609833f6902 class=toggle>
<label for=section-05ac7760b68f0e0530d0e609833f6902 class="flex justify-between"><a role=button class="navbutton
book-collapse-section">Scratch</a></label><ul><li><a href=/r/notes/scratch/colors/ class=navbutton>Adding Color</a></li><li><a href=/r/notes/scratch/crews2018/ class=navbutton>Crews (2018)</a></li><li><a href=/r/notes/scratch/datta2021/ class=navbutton>Datta (2021)</a></li><li><a href=/r/notes/scratch/drawing/ class=navbutton>Drawing Diagrams</a></li><li><a href=/r/notes/scratch/goedbloed/ class=navbutton>Goedbloed (2019)</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-c8688d5789736c2ae128963cf705a441 class=toggle>
<label for=section-c8688d5789736c2ae128963cf705a441 class="flex justify-between"><a href=/r/notes/griffiths/ class="navbutton
book-collapse-section">Griffiths Introduction to Electrodynamics</a></label><ul><li><a href=/r/notes/griffiths/ch1-1/ class=navbutton>Vector Algebra</a></li><li><a href=/r/notes/griffiths/ch1-2/ class=navbutton>Differential Calculus</a></li><li><a href=/r/notes/griffiths/ch1-3/ class=navbutton>Integral Calculus</a></li><li><a href=/r/notes/griffiths/ch1-4/ class=navbutton>Curvilinear Coordinates</a></li><li><a href=/r/notes/griffiths/ch1-5/ class=navbutton>The Dirac Delta Function</a></li><li><a href=/r/notes/griffiths/ch1-6/ class=navbutton>The Theory of Vector Fields</a></li><li><a href=/r/notes/griffiths/ch2-1/ class=navbutton>The Electric Field</a></li><li><a href=/r/notes/griffiths/ch2-2/ class=navbutton>Divergence and Curl of Electrostatic Fields</a></li><li><a href=/r/notes/griffiths/ch2-3/ class=navbutton>Electric Potential</a></li><li><a href=/r/notes/griffiths/ch2-4/ class=navbutton>Work and Energy in Electrostatics</a></li><li><a href=/r/notes/griffiths/ch2-5/ class=navbutton>Conductors</a></li><li><a href=/r/notes/griffiths/ch3-1/ class=navbutton>Laplace's Equation</a></li><li><a href=/r/notes/griffiths/ch3-2/ class=navbutton>The Method of Images</a></li><li><a href=/r/notes/griffiths/ch3-3/ class=navbutton>Separation of Variables</a></li><li><a href=/r/notes/griffiths/ch3-4/ class=navbutton>Multipole Expansion</a></li><li><a href=/r/notes/griffiths/ch4-1/ class=navbutton>Polarization</a></li><li><a href=/r/notes/griffiths/ch4-2/ class=navbutton>The Field of a Polarized Object</a></li><li><a href=/r/notes/griffiths/ch4-3/ class=navbutton>The Electric Displacement</a></li><li><a href=/r/notes/griffiths/ch4-4/ class=navbutton>The Linear Dielectrics</a></li><li><a href=/r/notes/griffiths/ch5-1/ class=navbutton>The Lorentz Force Law</a></li><li><a href=/r/notes/griffiths/ch5-2/ class=navbutton>The Biot-Savart Law</a></li><li><a href=/r/notes/griffiths/ch5-3/ class=navbutton>The Divergence and Curl of B</a></li><li><a href=/r/notes/griffiths/ch5-4/ class=navbutton>Magnetic Vector Potential</a></li><li><a href=/r/notes/griffiths/ch6-1/ class=navbutton>Magnetization</a></li><li><a href=/r/notes/griffiths/ch6-2/ class=navbutton>The Field of a Magnetized Object</a></li><li><a href=/r/notes/griffiths/ch6-3/ class=navbutton>The Auxiliary Field H</a></li><li><a href=/r/notes/griffiths/ch6-4/ class=navbutton>Linear and Nonlinear Media</a></li><li><a href=/r/notes/griffiths/ch7-1/ class=navbutton>Electromotive Force</a></li><li><a href=/r/notes/griffiths/ch7-2/ class=navbutton>Electromagnetic Induction</a></li><li><a href=/r/notes/griffiths/ch7-3/ class=navbutton>Maxwell's Equations</a></li><li><a href=/r/notes/griffiths/ch8-0/ class=navbutton>Phys 544 Introduction</a></li><li><a href=/r/notes/griffiths/ch8-1/ class=navbutton>Charge and Energy</a></li><li><a href=/r/notes/griffiths/ch8-2/ class=navbutton>Momentum</a></li><li><a href=/r/notes/griffiths/ch9-1/ class=navbutton>Electromagnetic Waves in One Dimension</a></li><li><a href=/r/notes/griffiths/ch9-2/ class=navbutton>Wave Equation for E and B</a></li><li><a href=/r/notes/griffiths/ch9-3/ class=navbutton>Electromagnetic Waves in Matter</a></li><li><a href=/r/notes/griffiths/ch9-4/ class=navbutton>Electromagnetic Waves in Conductors</a></li><li><a href=/r/notes/griffiths/ch9-5/ class=navbutton>Guided Waves</a></li><li><a href=/r/notes/griffiths/ch10-1/ class=navbutton>Scalar and Vector Potentials</a></li><li><a href=/r/notes/griffiths/ch10-2/ class=navbutton>Retarded Potentials</a></li><li><a href=/r/notes/griffiths/ch10-3/ class=navbutton>Point Charges</a></li><li><a href=/r/notes/griffiths/ch11-1/ class=navbutton>Dipole Radiation</a></li><li><a href=/r/notes/griffiths/problems-ch3/ class=navbutton>Solved Problems Ch3</a></li><li><a href=/r/notes/griffiths/problems-ch5/ class=navbutton>Solved Problems Ch5</a></li><li><a href=/r/notes/griffiths/problems-ch7/ class=navbutton>Solved Problems Ch7</a></li><li><a href=/r/notes/griffiths/problems-ch9/ class=navbutton>Solved Problems Ch9</a></li></ul></li></ul></li></ul><ul class=book-menu-hugo><li><a href=https://github.com/Peppyhare/r target=_blank rel=noopener>Github</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Hugo Themes</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/r/svg/menu.svg class=book-icon alt=Menu></label><h3>WARPXM 102 - Code Structure</h3><label for=toc-control><img src=/r/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#what-happens-when-you-press-go>What Happens When You Press Go?</a><ul><li><a href=#entrypoint>Entrypoint</a></li><li><a href=#setup>Setup</a><ul><li><a href=#domain-setup>Domain Setup</a></li><li><a href=#variable-setup>Variable Setup</a></li><li><a href=#host-action-initialization>Host Action Initialization</a></li></ul></li><li><a href=#solve>Solve</a><ul><li><a href=#pre-solve-actions>Pre-solve Actions</a></li><li><a href=#main-loop>Main Loop</a></li><li><a href=#class-diagrams>Class diagrams</a></li></ul></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><link rel=stylesheet href=/r/katex/katex.min.css><script defer src=/r/katex/katex.min.js></script><script defer src=/r/katex/auto-render.min.js onload=loadKatex()></script><span>\[\]
</span><script>function loadKatex(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}],throwOnError:!1,trust:e=>["\\htmlId","\\href"].includes(e.command),macros:{"\\lcm":"\\mathop{\\mathrm{lcm}}","\\sen":"\\text{sen}\\,","\\dd":"\\mathop{\\mathrm{d} #1}","\\abs":"\\lvert #1 \\rvert","\\dd":"\\text{d}","\\cross":"\\times","\\pdv":"\\frac{\\partial #1}{\\partial #2}","\\curl":`\\nabla \\cross #1`,"\\vu":"\\mathbf{\\hat{#1}}","\\vdot":"\\dot","\\div":`\\nabla \\cdot #1`,"\\grad":`\\nabla`,"\\dv":"\\frac{d\\,#1}{d\\,#2}","\\gr":"\\gamma","\\vec":"\\mathbf{#1}","\\tagl":"\\tag{#1}","\\eqref":"(#1)","\\laplacian":`\\mathbf{\\nabla ^2}`,"\\label":"{}","\\negadelta":`\\nabla`,"\\eqref":"\\href{###1}{(\\text{#1})}","\\ref":"\\href{###1}{\\text{#1}}","\\label":"\\htmlId{#1}{}"}})}</script><h1 id=what-happens-when-you-press-go>What Happens When You Press Go?
<a class=anchor href=#what-happens-when-you-press-go>#</a></h1><p>Following the sequence of events that take place in a WARPXM simulation by stepping through in the debugger has helped me to understand the code structure and concepts. I would highly recommend going through the process at least once. I have tried to explain what happens in plain English in the hopes that it will help me (and maybe someone else) to better understand how things are structured and what to expect when working with WARPXM.</p><p>There are some code listings (as they appear in the WARPXM code base) included for context that can be expanded by clicking on them.</p><h2 id=entrypoint>Entrypoint
<a class=anchor href=#entrypoint>#</a></h2><details><summary>`warpxm.cc: int main(int argc, char** argv)`</summary><div class=markdown-inner>```c++
int main(int argc, char** argv)
{
if (!warpxm_init(argc, argv)) { exit(-1); }
int res = 0;
// run top level warpxm main
res = warpxm_main(argc, argv);
warpxm_finalize();
return res;
}
```</div></details><p>The entrypoint for <code>warpxm</code> is simple, there are just three calls: <code>warpxm_init()</code>, <code>warpxm_main()</code>, and <code>warpxm_finalize()</code>. We don&rsquo;t need to pay much attention to <code>warpxm_init</code>, since it just initializes the MPI and PETSc frameworks. MPI is the message-passing framework that allows for massive parallelization. PETSc is a toolkit that helps us use MPI, parse command-line options, create meshes, and other things.</p><p><code>warpxm_main</code> is similarly high level:</p><details><summary>`warpxm.cc: int warpxm_main(int argc, char** argv)`</summary><div class=markdown-inner>```c++
int warpxm_main(int argc, char** argv)
{
// ...
// create new WARPXM simulation using the command line args
WmSimulation sim;
// Parse the input command
bool res = sim.parseCmdLine();
if (res) { return 0; }
// Read in the input file
std::ifstream inp(sim.getInpFileName().c_str());
// ... error checking ...
// Convert input file to a string
std::string inputStr((std::istreambuf_iterator<char>(inp)),
std::istreambuf_iterator<char>());
inp.seekg(0);
// Store the input file in the simulation
sim.setInputFileText(inputStr);
// create cryptset for simulation
WxCryptSet inputSet(inp);
// Step one - setup the simulation
sim.setup(inputSet);
// Step two - run the simulation
sim.simulate();
// Step three - drink to your success
return 0;
}
```</div></details><ul><li>Initialize our <code>WmSimulation</code> object. Nothing much happens when we init this other than creating a message-passing client (<code>WxMpiMsg</code>) and HDF5 i/o client (<code>WxHdf5Io</code>) that will be used to read/write data.</li><li>Parse the command-line options, simply reading the values of command-line flags.<ul><li><code>-input-file</code>/<code>-i</code> populates <code>inpFileName</code> with the input file contents, for parsing</li><li><code>-run-name</code>/<code>-n</code> populates <code>sim.runName</code></li><li><code>-restart-from-frame</code>/<code>-f</code> or <code>-restart-auto</code>/<code>-r</code> will populate <code>sim.restartFrame</code></li><li>If <code>-debug</code> was passed, the process waits for a debugger like <code>gdb</code> or <code>lldb</code> to attach to the process and allow things to continue.</li></ul></li><li>Turn the input file into a proper <code>WxCryptSet</code>, which is an immutable, nested map of name-value pairs for which each name is a string and each value is a native-type object, array of native objects, or another nested <code>WxCrypt</code>. I like to think about <code>WxCryptSet</code> as a thread-safe place to look up values which are global across the whole sim and which do not ever change, similar to the <code>Context</code>
<a href=https://docs.python.org/3/library/multiprocessing.html#multiprocessing-managers>objects used in Python&rsquo;s multiprocessing module</a>.<ul><li>This step involves parsing the full text of the input file, as described in
<a href=https://faculty.washington.edu/shumlak/WARPX/html/warpxm_input.html>https://faculty.washington.edu/shumlak/WARPX/html/warpxm_input.html</a></li></ul></li><li>Then, we do <code>sim.setup</code> and <code>sim.simulate</code> which cover the entire simulation</li></ul><h2 id=setup>Setup
<a class=anchor href=#setup>#</a></h2><details><summary>`wmsimulation.cc: void WmSimulation::setup(const WxCryptSet& wxc)`</summary><div class=markdown-inner>```c++
void WmSimulation::setup(const WxCryptSet& wxc)
{

    // determine run name
if (wxc.has("RunName"))
{
std::string possibleRunName = wxc.get<std::string>("RunName");
if (possibleRunName[0] == '/')
{
// This is a filename from root
runName = possibleRunName;
}
else
{
// This is a filename in the current directory
size_t trnc = inpFileName.find_last_of("/");
if (trnc != std::string::npos)
{
runName = inpFileName.substr(0, trnc) + "/" + possibleRunName;
}
else
{
runName = possibleRunName;
}
}
}
else if (runName == "")
{
runName = stripName(inpFileName);
}
// create WarpX root logger
WxLogger* wr = WxLogger::get("warpx-root");
// set root logger's verbosity level
std::string level;
if (wxc.has("GlobalVerbosity"))
level = wxc.get<std::string>("GlobalVerbosity");
else
level = "debug";
wr->setLevel(level);
// add file handler to root logger
std::ostringstream fn;
fn << runName << "_" << this->getMsg().rank() << ".log";
WxLogRecordHandler* wrfhndl = new WxFileHandler(fn.str());
wr->addHandler(wrfhndl);
// create WarpX console logger
WxLogger* wrc = WxLogger::get("warpx-root.console");
// set console logger's verbosity level
if (wxc.has("Verbosity"))
level = wxc.get<std::string>("Verbosity");
else
level = "debug";
wrc->setLevel(level);
// add stream handler to console
WxLogRecordHandler* wrshndl = new WxStreamHandler();
if (this->getMsg().rank() == 0)
// add console stream only on rank 0
wrc->addHandler(wrshndl);
// get output streams from newly created loggers
WxLogStream debStrm = wrc->getDebugStream();
WxLogStream infoStrm = wrc->getInfoStream();
WxLogStream errStrm = wrc->getErrorStream();
WxLogStream wrnStrm = wrc->getWarningStream();
//////////////////////////////
// now setup top level solver
debStrm << "Setting up WARPXM simulation..." << std::endl;
std::string simName;
// name of simulation to run
if (wxc.has("Simulation"))
{
simName = wxc.get<std::string>("Simulation");
}
else
{
// no simulation specified, so throw exception
WxExcept wxe("No Simulation key found in ");
wxe << inpFileName << std::endl;
throw wxe;
}
if (!wxc.hasSet(simName))
{
// solver not found
WxExcept wxe("ERROR: Solver set ");
wxe << simName << " not found" << std::endl;
throw wxe;
}
// get hold of solver's cryptset
const WxCryptSet& solverCrypt = wxc.getSet(simName);
debStrm << "Simulation name is " << simName << std::endl;
// while the general class structure is setup to handle registration and WxCreator
// process for getting new instances of WmSolverBase types
// as is done elsewhere in the code for WmVariables, and WmHostActions, for example,
// we have not implemented this functionality because
// there has only ever been one class implementation, WmSolver.
// To mimick the formatting at other levels of the crypt set, we at least check that
// the Type and Kind fields match what they should be.
if (solverCrypt.has("Type"))
{
std::string solverTypeStr = solverCrypt.get<std::string>("Type");
if (solverTypeStr != "WmSolverBase")
{
WxExcept wxe("Unrecognized Type field in input file for Simulation ");
wxe << simName << ". Only 'WmSolverBase' currently supported.";
throw wxe;
}
}
else
throw WxExcept("Simulation 'Type' field missing in input file.");
if (solverCrypt.has("Kind"))
{
std::string solverKindStr = solverCrypt.get<std::string>("Kind");
if (solverKindStr != "WmSolver")
{
WxExcept wxe("Unrecognized Kind field in input file for Simulation ");
wxe << simName << ". Only 'WmSolver' currently supported.";
throw wxe;
}
}
else
throw WxExcept("Simulation 'Kind' field missing in input file.");
// create new solver
solver = new WmSolver(this);
// set I/O for use in solver
solver->setIo(this->getIo());
// set msg for use in solver
solver->setMsg(this->getMsg());
// setup solver
solver->setup(solverCrypt);
}
```</div></details><p>A lot of things going on in <code>WmSimulation::setup</code>!</p><ul><li>Less important initialization: Ensure we have a <code>runName</code>, initialize the <code>WxLogger</code> loggers</li><li>Create a <code>WmSolver</code> and give it the same i/o and message clients as the <code>sim</code></li><li>Run <code>WmSolver.setup</code> with the <code>&lt;sim></code> node of the input file as input<ul><li>Sets the start and end times of the sim.</li><li>If the sim is being restarted (one of the restart command-line flags was passed), figure out the appropriate frame we should start at.</li><li>Set up the simulation domain</li><li>Create any variables defined in the input file</li><li>Initialize all host actions</li></ul></li></ul><h3 id=domain-setup>Domain Setup
<a class=anchor href=#domain-setup>#</a></h3><ul><li>Create a <code>WmDomain</code> object and run <code>WmDomain.setup</code><ul><li>Figure out how many different MPI processes are relevant, based on the <code>NumPartitions</code> field in the input file</li><li>Create a <code>mesh</code> from the <code>&lt;mesh></code> node of the input file<ul><li>If the sim is being restarted, look for the appropriate mesh <code>.h5</code> file in the working directory, and error if not found</li><li>Generate the appropriate type of mesh. This is usually a block mesh (<code>block_mesh</code>) which just contains equally-spaced cells, but can also be an arbitrary mesh.</li><li>Write the generated mesh definition to a file, e.g. <code>block_mesh_abd3712ea51f965c.inp</code></li><li>Break the mesh up into <code>WmUnstructuredPatch</code> patches so that it can be distributed across however many MPI processes we have.</li><li>Generate the appropriate geometry for each patch. For any local patches (patches which should be managed by the current MPI process), we generate the full mesh geometry as a <code>WmUnstructuredGeometry</code>, which is the basic structure we use to represent the geometric nodes for the mesh. Once the mesh is generated, we dump the mesh for each patch as an h5 file (<code>restartMesh...</code>) so that we may restart the simulation at a later time without needing to re-generate the geometry.</li><li>We use DG basis elements to represent the mesh, so we also export the basis decomposition for the patch domain as an h5 file (<code>plotMesh...</code>), so that it is possible to reconstruct the physical geometry for later plotting and analysis</li></ul></li></ul></li></ul><h3 id=variable-setup>Variable Setup
<a class=anchor href=#variable-setup>#</a></h3><ul><li>For each variable defined in the input file (everything of <code>Type = variable</code>) we initialize that variable setting its basis according the domain we computed above</li><li>For the hybrid kinetic solver, we additionally compute bases for the velocity space elements here.</li><li>Variables are not set to their initial values yet; that is done by a variable adjuster host action (<code>va_runner</code>) next</li></ul><h3 id=host-action-initialization>Host Action Initialization
<a class=anchor href=#host-action-initialization>#</a></h3><ul><li>Each host action (<code>Type = WmHostAction|host_action|subsolver</code>) gets setup and inserted into the hostActions map. Different types of host action have different setup steps and effects. There are <a href=/r/img/research/warpxm/classdiagram-hostaction.png>a lot</a> of different types that directly extend <code>WmHostAction</code> in WARPXM, but the top-level ones relevant to most sims are:<ul><li><strong>Time Integrator</strong>: The time integrator that moves the state forward in time. This will almost always be the explicit Runge-Kutta temporal solver.</li><li><strong>Patch Processors</strong>: This coordinates patch processes across the domain. Patch processes are any process which can be evaluated locally within a single patch. For example, the spatial solver is a patch process which is called by the time integrator host action to compute \( \pdv{q}{t} \) (by implementing the nodal discontinuous Galerkin method). Variable adjusters which set/modify the value of variables across the domain are another common example, and are used to set initial conditions as we&rsquo;ll see later.</li><li><strong>Writers</strong>: Two types of writer: frame writers and diagnostic writers. A frame writer dumps the current variables to disk in HDF5 format each frame. The frame writer only needs to write the current data for the local patch, as opposed to diagnostic writers which are typically used to integrate variables across the global domain. Diagnostics can be <code>Probe</code>s (simply retrieve the current value of variables) or <code>WmIntegrator</code>s (integrate an expression over the domain or a subdomain). At pre-defined time intervals, the diagnostics writer evaluates each defined diagnostic and writes the result to a CSV file.</li><li><strong>Synchronizer</strong> When we require data that spans patches hosted on different MPI processes, an asynchronous process is required to manage the requesting and copying of that data.</li></ul></li></ul><h2 id=solve>Solve
<a class=anchor href=#solve>#</a></h2><p>This is where the real work happens, so we need to pay extra attention here</p><details><summary>`wmsolver.cc: void WmSolver::solve()`</summary><div class=markdown-inner>```c++
void WmSolver::solve()
{
WxLogger* log = WxLogger::get("warpx-root.console");
WxLogStream infStrm = log->getInfoStream();
WxLogStream debStrm = log->getDebugStream();
WxLogStream errStrm = log->getErrorStream();
presolve();
real frame_time = (_tend - _tstart) / _nout;
auto start_time = getCurrentTime();
auto start_frame = getCurrentFrame();
wxm::timer::TIMER.start(wxm::timer::ROOT_TIMING_SCOPE);
for (size_t i = getCurrentFrame(); i < _nout; ++i)
{
auto frame_stop_time = start_time + (i + 1 - start_frame) * frame_time;
infStrm << "Advancing solution starting at time " << getCurrentTime() << " to "
<< frame_stop_time << "...\n";
// Instantiate a new timer and most restrictive timestep constraint
WxTimer advTimer;
TimestepConstraint most_restrictive_tc;
// Perform frame advance, catch any exception.
advTimer.startTimer();
try
{
most_restrictive_tc = advance(frame_stop_time);
}
catch (WxExcept wxe)
{
infStrm << "Exception caught, simulation exiting. See error log for details." << std::endl << std::endl;
errStrm << "\nException caught in wxm::wmsolver::solve() at t = " << getCurrentTime() << std::endl;
errStrm << wxe.what() << std::endl << std::endl;
exit(EXIT_FAILURE);
}
advTimer.stopTimer();
// Report on frame advance
infStrm << "Advanced from frame " << getCurrentFrame() << " to "
<< getCurrentFrame() + 1 << " in " << advTimer.timeElapsedAsString()
<< ". ";
infStrm << "Current dt = " << getDt() << "\n";
// Report the most restrictive tc among each frame
infStrm << "Most restrictive timestep constraint this period was:\n";
infStrm << "\t{dt = " << most_restrictive_tc.getDt() << ", "
<< "physics = '" << *most_restrictive_tc.getPhysics() << "', "
<< "x = (" << most_restrictive_tc.getX()[0] << ", "
<< most_restrictive_tc.getX()[1] << ", " << most_restrictive_tc.getX()[2]
<< ")}\n\n";
// Walltime report in the debug stream
wxm::timer::TIMER.print_timings(debStrm);
incrementCurrentFrame();
}
// upon completing the all specified simulation, run EndOnly steps
debStrm << "\nRunning EndOnly steps...\n" << std::endl;
endOnly();
// Walltime report
wxm::timer::TIMER.print_timings(infStrm);
}
```</div></details><h3 id=pre-solve-actions>Pre-solve Actions
<a class=anchor href=#pre-solve-actions>#</a></h3><ul><li>First, we run through the <code>presolve</code> steps:<details><summary>`wmsolver.cc: void WmSolver::presolve()`</summary><div class=markdown-inner>```c++
void WmSolver::presolve()
{
// fetch stream for logging messages
WxLogger* log = WxLogger::get("warpx-root.console");
WxLogStream infStrm = log->getInfoStream();
WxLogStream debStrm = log->getDebugStream();
const bool fromRestart = (getCurrentFrame() != 0);
// initialize hostactions
for (auto& ha : _hostActions)
  {
      ha.second->init();
}
// initialize subsolvers
for (auto& ss : _subSolvers)
  {
      ss.second->init();
}
// Run the initialization steps
if (fromRestart)
{
// run startOnly subsolvers
debStrm << "Running Restart steps...\n" << std::endl;
restart();
}
else
{
// run startOnly subsolvers
debStrm << "Running StartOnly steps...\n" << std::endl;
startOnly();
}
}
```</div></details><ul><li>Call the optional <code>init()</code> function for each defined host action and sub-solver</li><li>Then, we perform a single <code>ha->step()</code> for each host action in the sim&rsquo;s <code>start_only_group</code> list. Per the definition in the parent <code>WxStepper</code> class, the <code>step()</code> method for a host action must advance the state of the object by the assigned time step dt, getDt(). This is where we set the initial conditions for each defined variable. In warpy, these are defined by supplying a list of variable adjusters to the <code>initial_conditions</code> parameter of a <code>warpy.dg_sim</code> object.<ul><li>For a <code>va_runner</code> host action, <code>step()</code> means:<ul><li>For each variable adjuster in the host action, call <code>va->solve(time, variables_)</code> to update <code>variables_</code> as appropriate for the current time. In doing so, we need to look up the local patch arrays for the variables being adjusted, loading the physical geometry (e.g. <code>(x,y,z)</code>, <code>(dx, dy, dz)</code>) from the basis for element in the patch, and evaluating each <code>WmApplication</code> in the application list for this variable adjuster on each element in the patch.</li></ul></li></ul></li></ul></li></ul><h3 id=main-loop>Main Loop
<a class=anchor href=#main-loop>#</a></h3><ul><li><p>In the main loop, we try to advance the solution from the current frame (0 at the start) to the next frame until we reach the end of the time interval (the last frame). The total number of frames we need to advance is the total number of write-out steps specified in the input file. For example, if our input file has <code>Time = [0, 10.0]</code> and <code>Out = 100</code> in the top-level <code>&lt;sim></code> block, we will have 100 frames that correspond with <code>t = [0.0, 0.1, 0.2, ..., 10.0]</code>. Each pass of the <code>for (size_t i = getCurrentFrame(); i &lt; _nout; ++i)</code> loop calls <code>WmSolver::advance()</code> to advance to the next frame.</p></li><li><p>In between each frame, we write out informational log messages (that show the amount of actual time we took to advance to the next frame and the value of the most restrictive timestep) to provide some feedback while the sim is running.</p><details><summary>`wmsolver.cc: TimestepConstraint WmSolver::advance()`</summary><div class=markdown-inner>```c++
TimestepConstraint WmSolver::advance(real tend)
{
WxLogger* log = WxLogger::get("warpx-root.console");
WxLogStream debStrm = log->getDebugStream();
WxLogStream infStrm = log->getInfoStream();
unsigned nstep = 1;
auto tstart = getCurrentTime();
// This says to not set the timestep below this limit
const real limit_dt = std::max(std::fabs(tend), std::fabs(tstart)) * 100.0 *
std::numeric_limits<real>::epsilon();
const real limit_t = tend * (1 - 5 * std::numeric_limits<real>::epsilon());
WxMsgBase& msg = getMsg();
TimestepConstraint most_restrictive_tc = TimestepConstraint();
// loop advancing solution using adaptive time-stepping
while (getCurrentTime() < limit_t)
{
auto t = getCurrentTime();
auto dt = getDt();
if (!flexible_writeout)
{
dt = std::min<real>(dt, limit_t - t);
}
// Instantiate new iterations total and timestep constraint
int iters;
std::shared_ptr<timestepconstraint> tc;
// Take time step
auto tmp = step_dt(dt, limit_dt);
iters = tmp.first;
tc = tmp.second.get_tc();
// Let user know that the step has ended
debStrm << " Ending Step " << nstep << " after " << iters + 1
<< " attempts for t = " << t << " -> " << getCurrentTime()
<< " using dt = " << tc->getDt() << std::endl;
// Report the physics and location that restrict the time step dt
debStrm << "\t tc = {dt = " << tc->getDt() << ", "
<< "physics = '" << *(tc->getPhysics()) << ", "
<< "x = (" << tc->getX()[0] << ", " << tc->getX()[1] << ", "
<< tc->getX()[2] << ")}\n\n";
setDt(tc->getDt());
most_restrictive_tc = TimestepConstraint::minDt(*tc, most_restrictive_tc);
++nstep;
}
return most_restrictive_tc;
}
```</div></details></li><li><p>Note that within <code>advance()</code>, we have a <code>while (getCurrentTime() &lt; limit_t)</code> loop to increment forwards in time. We continue stepping until we have reached the next frame, which could require many many individual <code>dt</code> timesteps.</p></li><li><p>On the first step, the solver attempts to advance time by the <code>dt_controller</code>&rsquo;s initial <code>dt</code>. Subsequent steps may try to advance by a larger or smaller <code>dt</code> if the <code>dt_controller</code> provided in the input file is not a <code>time_stepper.fixed_dt</code>.</p></li><li><p>For each host action in the per-step group, we tick forward with <code>host_action->step()</code></p><ul><li>We can peek at <code>tools/warpy/dg_sim.py</code> to see what host actions should be the per-step group for a DG sim. With some abbreviation, we see:<details><summary>`tools/warpy/dg_sim.py: dg_sim.__init__()`</summary><div class=markdown-inner>```python
# w_group is the group of writer host actions provided in the warpy input file
w_group = solver_sequence.sequence_group(name='write_group', actions=writers)
# ps_group contains the temporal solvers provided in the warpy input file,
# sandwiched between any optional pre- or post-time-integration actions
ps_group = solver_sequence.sequence_group(
name='perstep_group',
actions=pre_ti_host_actions + temporal_solvers + post_ti_host_actions
)
# swap_group
swapper = host_actions.swapper(
name='swapper',
srcs=[v.name(0) for v in evolve_vars],
dsts=[v.name(v.output_stage if (hasattr(v, 'output_stage')) else None) for v in evolve_vars]
)
swap_group = solver_sequence.sequence_group(name='swap_group', actions=[swapper])
# So per-step host actions are the writers, followed by the temporal solvers, followed by swappers
ps_step = [w_group, ps_group, swap_group]
ss = solver_sequence.solver_sequence(
start_only=so_step,
per_step=ps_step,
per_redo_per_step=r_step,
end_only=eo_step,
restart=res_step
)
super(dg_sim, self).__init__(solver_sequence=ss, ...)
```</div></details><ul><li><p>The big one is of course the temporal solver. For pretty much everything we&rsquo;re using WARPXM for, that&rsquo;s going to be a <code>Kind = explicit_runge_kutta</code> host action (the implicit solver still exists but is rarely used), which maps to a <code>WmTemporalSolver_RK</code>.</p><details><summary>`src/dfem/temporal_solvers/wmtemporalsolver_rk.h: WxStepperStatus WmTemporalSolver_RK::step()`</summary><div class=markdown-inner>```c++
WxStepperStatus WmTemporalSolver_RK::step()
{
wxm::timer::TIMER.start("rk_solver/step");
time_t time = getCurrentTime();
time_t dt = getDt();
std::shared_ptr<timestepconstraint> sugg_tc = std::make_shared<timestepconstraint>();
for (int rk_stage = 0; rk_stage < scheme_->getNumStages(); rk_stage++)
{
const real current_time = time + scheme_->getTimeUpdate(rk_stage) * dt;
variables_type& q_n = variables_[rk_stage];
variables_type& q_p = variables_[rk_stage + 1];
// zero out q_p which are temporal vars
fill_local(rk_stage + 1);
// TODO: this is only here until zero_fluxes is implemented with scopes
for (auto& ss : spatial_solvers_)
  {
      ss->zero_fluxes();
}
// run all variable adjusters
{
size_t idx = 0;
for (size_t i = min_priority; i <= max_priority; ++i)
{
while (idx < va_priorities.size() && va_priorities[idx] <= i)
       {
adjusters_[idx]->solve(current_time, q_n);
adjusters_[idx]->Barrier(getMsg(), current_time, q_n);
++idx;
}
wxm::timer::TIMER.start("rk_sync");
// Initiate syncing on every MPI rank
start_sync(rk_stage);
// Wait for syncing to finish
finish_sync(rk_stage);
wxm::timer::TIMER.stop();
}
}
// run the spatial solvers
for (auto& ss : spatial_solvers_)
  {
			std::shared_ptr<timestepconstraint> tc = ss->solve(current_time, q_n, q_p);
// Comparing spatial_solver's suggested time step with current minimum suggested time step.
// Updating sugg_tc if new minimum
*sugg_tc = TimestepConstraint::minDt(*sugg_tc, *tc);
ss->Barrier(getMsg(), current_time, q_p);
}
// rhs is now in q_p; need to accumulate with previous q's to get actual q_p
scheme_->calc_stage(rk_stage, temporal_vars_, variables_, dt);
wxm::timer::TIMER.start("rk_sync");
// Initiate syncing on every MPI rank
start_sync(rk_stage + 1);
// Wait for syncing to finish
finish_sync(rk_stage + 1);
wxm::timer::TIMER.stop();
}
wxm::timer::TIMER.stop(); // for "rk_solver/step"
// TODO: how to get time step limit to take into account sources/diffusion/advection?
return WxStepperStatus(dt <= sugg_tc->getDt(), sugg_tc);
}
```</div></details></li></ul></li></ul></li></ul><p>The Runge-Kutta temporal solver has multiple &ldquo;stages&rdquo;, depending on the temporal order specified in the input file. These stages are the standard Runge-Kutta intermediate approximations of the solution in between <code>t</code> and <code>t + dt</code> which are combined in a weighted average to advance the solution. For each stage:</p><ul><li>Run any variable adjusters associated with the temporal solver. In the case of the <code>advection.py</code> example, we use a shock-capturing limiter (<code>warpy.variable_adjusters.limiters.dg_moe_rossmanith</code>) which enforces local bounds on variables by damping the high-order corrections.</li><li>The DG spatial solver comes next, and this is where the really heavy lifting happens. The actual flux calculations are up to the <code>WmApplication</code>(s) that we&rsquo;ve defined in our input file. To express the physics of the problem in the language of DG, an application can define:<ul><li><code>numerical_flux()</code>: Compute boundary flux over the surface of a DG element</li><li><code>internal_flux()</code>: Compute volume flux within a DG element</li><li><code>source()</code>: Contribute a source/sink term</li><li><code>bc_q()</code>: Set the value of &ldquo;ghost&rdquo; nodes on the domain boundary</li><li><code>bcNumericalFlux()</code>: Conpute boundary flux for element faces on the domain boundary</li></ul></li></ul><p>I don&rsquo;t pretend to fully understand the DG implementation in WARPXM just yet, so I may get some things slightly wrong here. As far as I can tell, the calculation of $\pdv{q}{t}$ has been intentionally broken up into three separate &ldquo;kernel&rdquo; methods: <code>in_kernel</code>, <code>ex_kernel</code>, and <code>rhs_kernel</code>. In this case, use of the word &ldquo;
<a href=https://en.wikipedia.org/wiki/Compute_kernel>kernel</a>&rdquo; is meant to indicate that these are the inner-most methods where the real number crunching happens.</p><ol><li><code>in_kernel</code>: Compute the internal flux within each DG element<ul><li>If there are apps with sources that require computing Gaussian quadrature, we compute those quadrature points and call <code>app->source()</code> to allow the app to do its thing and compute the source flux on the element.</li><li>After loading the variables and node geometry for the current patch, the internal flux computation is all up to the application when we call <code>app->internal_flux()</code> for each app to compute the internal flux on the element.</li></ul></li><li><code>ex_kernel</code>: Compute the flux across each face of the element. For each app we call <code>app->numerical_flux()</code> to get the flux for each element face. Then, for the boundary conditions, we collect the set of boundary faces in the patch and for each one we find applications that supply a <code>bcNumericalFlux()</code> function and call it, summing up the results.</li><li><code>rhs_kernel</code>: This is basically just combining the individual terms together into the right-hand-side of eq. 3.3.21 from
<a href="https://www.proquest.com/dissertations-theses/domain-hybridized-plasma-model-using/docview/2594528326/se-2?accountid=14784">Iman&rsquo;s dissertation</a>:
<span>\[\underbrace{\pdv{}{t} q_{ij} ^ \lambda}_{\text{rhs\_kernel}} = \underbrace{J_ {ml} ^\lambda \Upsilon _{jlk} f^ \lambda _{imk}}_{\text{in\_kernel}} - \underbrace{\sum_{\gamma \in \tilde{\Gamma} _\lambda} G_{\lambda \gamma} \Xi _{jk} ^{\lambda \gamma} F_{ik} ^{\lambda \gamma} + \Psi _{jk} s_{ik} ^{\lambda}}_{\text{ex\_kernel}}\]
</span><script>function loadKatex(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}],throwOnError:!1,trust:e=>["\\htmlId","\\href"].includes(e.command),macros:{"\\lcm":"\\mathop{\\mathrm{lcm}}","\\sen":"\\text{sen}\\,","\\dd":"\\mathop{\\mathrm{d} #1}","\\abs":"\\lvert #1 \\rvert","\\dd":"\\text{d}","\\cross":"\\times","\\pdv":"\\frac{\\partial #1}{\\partial #2}","\\curl":`\\nabla \\cross #1`,"\\vu":"\\mathbf{\\hat{#1}}","\\vdot":"\\dot","\\div":`\\nabla \\cdot #1`,"\\grad":`\\nabla`,"\\dv":"\\frac{d\\,#1}{d\\,#2}","\\gr":"\\gamma","\\vec":"\\mathbf{#1}","\\tagl":"\\tag{#1}","\\eqref":"(#1)","\\laplacian":`\\mathbf{\\nabla ^2}`,"\\label":"{}","\\negadelta":`\\nabla`,"\\eqref":"\\href{###1}{(\\text{#1})}","\\ref":"\\href{###1}{\\text{#1}}","\\label":"\\htmlId{#1}{}"}})}</script>where $f^\lambda _{imk}$ is the internal flux computed above, $F _{ik} ^{\lambda \gamma}$ is the external flux computed above, $s _ {ik} ^{\lambda}$ is the source flux, and $ J _ {ml} ^\lambda \Upsilon _ {jlk} $, $ G _ {\lambda \gamma} \Xi _ {jk} ^{\lambda \gamma}$, and $\Psi _ {jk}$ are computed directly from the geometry and nodal basis for each element.</li></ol><ul><li><p>Each of these flux calculations and patch processes results may produce a timestep constraint, which gives the minimum allowable <code>dt</code> for the next step based on e.g. CFL condition. We always take the smallest constraint before moving forward.</p></li><li><p>Finally, once we&rsquo;ve (hopefully) stepped all the way to the final frame, each host action in the end-only-group (typically just the writers) gets a <code>step()</code> to write out the final frame&rsquo;s data, and the sim is done!</p></li></ul><h3 id=class-diagrams>Class diagrams
<a class=anchor href=#class-diagrams>#</a></h3><p>When trying to visualize how the different classes in the WARPXM codebase interact, I found it useful at some points to refer to class hierarchy diagrams. These diagrams can ge benerated to show the inheritance hierarchy of all classes in the C++ code from top (parent) to bottom (child). These diagrams can be generated as part of the Doxygen documentation by setting <code>CLASS_DIAGRAMS = true</code> and <code>HAVE_DOT = true</code> in the
<a href=https://github.com/UW-Computational-Plasma-Group/warpxm/blob/master/doxyfile.in>doxygen input file</a> and re-building the documentation. Need to make sure that
<a href=https://www.graphviz.org/>graphviz</a> is installed locally in order to draw the generated diagrams.</p><p>Class diagrams generated by Doxygen showing all the different implementations of patch processes we&rsquo;ve currently got:</p><p align=center><img alt=img/research/warpxm/classdiagram-WmPatchProcess.png src=/r/img/research/warpxm/classdiagram-WmPatchProcess.png></p><p align=center><img alt=img/research/warpxm/classdiagram-variable_adjuster_t.png src=/r/img/research/warpxm/classdiagram-variable_adjuster_t.png></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/Peppyhare/r/commit/5644403c256b86215838af0692b160f321eb170a title='Last modified by Evan Bluhm | February 12, 2025' target=_blank rel=noopener><img src=/r/svg/calendar.svg class=book-icon alt>
<span>February 12, 2025</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#what-happens-when-you-press-go>What Happens When You Press Go?</a><ul><li><a href=#entrypoint>Entrypoint</a></li><li><a href=#setup>Setup</a><ul><li><a href=#domain-setup>Domain Setup</a></li><li><a href=#variable-setup>Variable Setup</a></li><li><a href=#host-action-initialization>Host Action Initialization</a></li></ul></li><li><a href=#solve>Solve</a><ul><li><a href=#pre-solve-actions>Pre-solve Actions</a></li><li><a href=#main-loop>Main Loop</a></li><li><a href=#class-diagrams>Class diagrams</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>