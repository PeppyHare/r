<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="




  \[\]


Let&rsquo;s try to make sense of the unstructured geometry library that WARPX uses to work with unstructured meshes"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://peppyhare.github.io/r/notes/research/warpxm-201/"><meta property="og:site_name" content="My Notes"><meta property="og:title" content="WARPXM 201 - Unstructured Geometry"><meta property="og:description" content="\[\] Letâ€™s try to make sense of the unstructured geometry library that WARPX uses to work with unstructured meshes"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta property="article:modified_time" content="2025-08-29T15:50:33-07:00"><title>WARPXM 201 - Unstructured Geometry | My Notes</title><link rel=icon href=/r/favicon.png><link rel=manifest href=/r/manifest.json><link rel=canonical href=https://peppyhare.github.io/r/notes/research/warpxm-201/><link rel=stylesheet href=/r/book.min.b1d1e119348cf3511b9b865854b426d908b8949927347c700c19497f9351531c.css integrity="sha256-sdHhGTSM81Ebm4ZYVLQm2Qi4lJknNHxwDBlJf5NRUxw=" crossorigin=anonymous><script defer src=/r/fuse.min.js></script><script defer src=/r/en.search.min.95b09690dcd974647b8b9df8a44a625285ed8ca404c8b4f888c83681b0081108.js integrity="sha256-lbCWkNzZdGR7i534pEpiUoXtjKQEyLT4iMg2gbAIEQg=" crossorigin=anonymous></script><script defer src=/r/sw.min.9e3a83f0b071ebe0141a16a33db93faadb2bdf712473a218febeed35ed243c08.js integrity="sha256-njqD8LBx6+AUGhajPbk/qtsr33Ekc6IY/r7tNe0kPAg=" crossorigin=anonymous></script><link rel=preload href=/r/katex/fonts/KaTeX_Main-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/r/katex/fonts/KaTeX_Main-Bold.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/r/katex/fonts/KaTeX_Main-Italic.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/r/katex/fonts/KaTeX_Math-Italic.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/r/katex/fonts/KaTeX_Size2-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/r/katex/fonts/KaTeX_Size3-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/r/fonts/roboto-v27-latin-regular.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/r/fonts/roboto-v27-latin-700.woff2 as=font type=font/woff2 crossorigin=anonymous></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/r/><span>My Notes</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/r/svg/translate.svg class=book-icon alt=Languages>
English</a></label><ul></ul></li></ul><ul><li class=book-section-flat><ul><li class=book-section-flat><input type=checkbox id=section-f04c181c9b16a37431fe06303d58b7a0 class=toggle>
<label for=section-f04c181c9b16a37431fe06303d58b7a0 class="flex justify-between"><a href=/r/notes/UWAA545/ class="navbutton
book-collapse-section">Computational Methods For Plasmas</a></label><ul><li><a href=/r/notes/UWAA545/01-syllabus/ class=navbutton>Syllabus</a></li><li><a href=/r/notes/UWAA545/02-plasma-models/ class=navbutton>Plasma Models</a></li><li><a href=/r/notes/UWAA545/03-pic-method/ class=navbutton>Particle in Cell Model</a></li><li><a href=/r/notes/UWAA545/04-pic-example/ class=navbutton>PIC - Example Implementation</a></li><li><a href=/r/notes/UWAA545/05-electrodynamic-pic/ class=navbutton>Multidimensional Electrodynamic PIC</a></li><li><a href=/r/notes/UWAA545/06-fluid-models/ class=navbutton>Fluid Models for Plasmas</a></li><li><a href=/r/notes/UWAA545/07-finite-difference-models/ class=navbutton>Finite Difference Methods for MHD</a></li><li><a href=/r/notes/UWAA545/08-mhd-equilibrium/ class=navbutton>MHD Equilibrium Calculations</a></li><li><a href=/r/notes/UWAA545/formulary/ class=navbutton>Formulary</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-b6bdf3598cf4214623cd2f8ff7b6e0f2 class=toggle>
<label for=section-b6bdf3598cf4214623cd2f8ff7b6e0f2 class="flex justify-between"><a href=/r/notes/UWAA560/ class="navbutton
book-collapse-section">Plasma Diagnostics</a></label><ul><li><a href=/r/notes/UWAA560/01-syllabus/ class=navbutton>Syllabus</a></li><li><a href=/r/notes/UWAA560/02-diagnostic-considerations/ class=navbutton>General Diagnostic Considerations</a></li><li><a href=/r/notes/UWAA560/03-magnetic-field-diagnostics/ class=navbutton>Magnetic Field Diagnostics</a></li><li><a href=/r/notes/UWAA560/04-electrostatic-diagnostics/ class=navbutton>Electrostatic Diagnostics</a></li><li><a href=/r/notes/UWAA560/05-index-of-refraction-measurements/ class=navbutton>Index of Refraction Measurements</a></li><li><a href=/r/notes/UWAA560/06-spectroscopic-measurements/ class=navbutton>Spectroscopic Measurements</a></li><li><a href=/r/notes/UWAA560/90-student-lectures/ class=navbutton>Student Lectures</a></li><li><a href=/r/notes/UWAA560/91-zeeman-spectroscopy/ class=navbutton>My class lecture</a></li><li><a href=/r/notes/UWAA560/formulary/ class=navbutton>Formulary</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-5b051410be8cdb0f46ad32fc2ad5a20d class=toggle>
<label for=section-5b051410be8cdb0f46ad32fc2ad5a20d class="flex justify-between"><a href=/r/notes/UWAA558/ class="navbutton
book-collapse-section">MHD Theory</a></label><ul><li><a href=/r/notes/UWAA558/01-syllabus/ class=navbutton>Syllabus</a></li><li><a href=/r/notes/UWAA558/02-plasma-models/ class=navbutton>Plasma Models</a></li><li><a href=/r/notes/UWAA558/03-plasma-fluid-model/ class=navbutton>Plasma Fluid Model</a></li><li><a href=/r/notes/UWAA558/04-two-fluid-plasma-model/ class=navbutton>Two-Fluid Plasma Model</a></li><li><a href=/r/notes/UWAA558/05-mhd-model/ class=navbutton>Magnetohydrodynamic (MHD) Model</a></li><li><a href=/r/notes/UWAA558/06-boundary-conditions/ class=navbutton>Boundary Conditions</a></li><li><a href=/r/notes/UWAA558/07-equilibrium-for-fusion/ class=navbutton>Equilibrium for Fusion</a></li><li><a href=/r/notes/UWAA558/08-1d-equilibria/ class=navbutton>1-D Equilibria</a></li><li><a href=/r/notes/UWAA558/09-2d-equilibria/ class=navbutton>2D Equilibria</a></li><li><a href=/r/notes/UWAA558/10-equilibrium-of-3d-configurations/ class=navbutton>Equilibrium of 3D Configurations</a></li><li><a href=/r/notes/UWAA558/11-mhd-stability/ class=navbutton>MHD Stability</a></li><li><a href=/r/notes/UWAA558/formulary/ class=navbutton>Formulary</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-c3201a1057283cb12ab09a42fe89bfb2 class=toggle checked>
<label for=section-c3201a1057283cb12ab09a42fe89bfb2 class="flex justify-between"><a href=/r/notes/research/ class="navbutton
book-collapse-section">Research Notes</a></label><ul><li><a href=/r/notes/research/dgh-datta/ class=navbutton>Electrodynamic Dory-Guest-Harris Instability</a></li><li><a href=/r/notes/research/valgrind/ class=navbutton>Valgrind</a></li><li><a href=/r/notes/research/warpxm-101/ class=navbutton>WARPXM 101 - Getting Started</a></li><li><a href=/r/notes/research/warpxm-102/ class=navbutton>WARPXM 102 - Code Structure</a></li><li><a href=/r/notes/research/warpxm-201/ class="active navbutton">WARPXM 201 - Unstructured Geometry</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-34991d35561e8d266d64d5d323e97c7a class=toggle>
<label for=section-34991d35561e8d266d64d5d323e97c7a class="flex justify-between"><a href=/r/notes/UWAA557/ class="navbutton
book-collapse-section">Physics of Fusion Plasmas</a></label><ul><li><a href=/r/notes/UWAA557/ch10-0/ class=navbutton>Rules of thumb</a></li><li><a href=/r/notes/UWAA557/ch10-1/ class=navbutton>Statistical Mechanics</a></li><li><a href=/r/notes/UWAA557/ch10-2/ class=navbutton>Review of E&amp;M</a></li><li><a href=/r/notes/UWAA557/ch10-3/ class=navbutton>Lagrange Multipliers</a></li><li><a href=/r/notes/UWAA557/ch11-1/ class=navbutton>Wall-supported Plasma</a></li><li><a href=/r/notes/UWAA557/ch11-2/ class=navbutton>Collisions</a></li><li><a href=/r/notes/UWAA557/ch11-3/ class=navbutton>Oscillations</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-7c7b4e4d4494a744744faedd969cb670 class=toggle>
<label for=section-7c7b4e4d4494a744744faedd969cb670 class="flex justify-between"><a href=/r/notes/UWAA543/ class="navbutton
book-collapse-section">Computational CFD</a></label><ul><li><a href=/r/notes/UWAA543/ch20-1/ class=navbutton>Introduction to Computational CFD</a></li><li><a href=/r/notes/UWAA543/ch20-2/ class=navbutton>Governing Equations</a></li><li><a href=/r/notes/UWAA543/ch20-3/ class=navbutton>Reduced Models</a></li><li><a href=/r/notes/UWAA543/ch20-4/ class=navbutton>Equation Types</a></li><li><a href=/r/notes/UWAA543/ch20-5/ class=navbutton>Panel Method</a></li><li><a href=/r/notes/UWAA543/ch21-1/ class=navbutton>Finite Difference Algorithms</a></li><li><a href=/r/notes/UWAA543/ch21-2/ class=navbutton>Explicit Finite Difference Algorithms</a></li><li><a href=/r/notes/UWAA543/ch21-3/ class=navbutton>Finite Difference and Finite Volume Methods</a></li><li><a href=/r/notes/UWAA543/ch21-4/ class=navbutton>Implicit Algorithms</a></li><li><a href=/r/notes/UWAA543/ch21-5/ class=navbutton>Numerical Boundary Conditions</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-e5f141895443fc824f58730f7904d483 class=toggle>
<label for=section-e5f141895443fc824f58730f7904d483 class="flex justify-between"><a href=/r/notes/UWAA556/ class="navbutton
book-collapse-section">Plasma Waves</a></label><ul><li><a href=/r/notes/UWAA556/ch01-1/ class=navbutton>Mathematical review</a></li><li><a href=/r/notes/UWAA556/ch02-1/ class=navbutton>Plasma Waves in General Dielectric Media</a></li><li><a href=/r/notes/UWAA556/ch02-2/ class=navbutton>Wave Properties in Cold Unmagnetized Plasma</a></li><li><a href=/r/notes/UWAA556/ch02-3/ class=navbutton>Cold Magnetized Plasma Dispersion Relation</a></li><li><a href=/r/notes/UWAA556/ch02-4/ class=navbutton>The CMA Diagram</a></li><li><a href=/r/notes/UWAA556/ch03-1/ class=navbutton>Introduction to Kinetic Theory</a></li><li><a href=/r/notes/UWAA556/ch03-2/ class=navbutton>Landau Damping</a></li><li><a href=/r/notes/UWAA556/ch03-3/ class=navbutton>Waves in Hot Magnetized Plasma</a></li><li><a href=/r/notes/UWAA556/ch04-1/ class=navbutton>Fluid stuff</a></li><li><a href=/r/notes/UWAA556/ch04-2/ class=navbutton>Quasi-Linear Theory</a></li><li><a href=/r/notes/UWAA556/ch05-1/ class=navbutton>Diffusion and Resistivity</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-3a2759a8b11b3422da800ed19897932a class=toggle>
<label for=section-3a2759a8b11b3422da800ed19897932a class="flex justify-between"><a href=/r/notes/problems/ class="navbutton
book-collapse-section">Worked Problems</a></label><ul><li><a href=/r/notes/problems/gurnett/ch02/ class=navbutton>Characteristic Parameters of a Plasma</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-05ac7760b68f0e0530d0e609833f6902 class=toggle>
<label for=section-05ac7760b68f0e0530d0e609833f6902 class="flex justify-between"><a role=button class="navbutton
book-collapse-section">Scratch</a></label><ul><li><a href=/r/notes/scratch/colors/ class=navbutton>Adding Color</a></li><li><a href=/r/notes/scratch/crews2018/ class=navbutton>Crews (2018)</a></li><li><a href=/r/notes/scratch/datta2021/ class=navbutton>Datta (2021)</a></li><li><a href=/r/notes/scratch/drawing/ class=navbutton>Drawing Diagrams</a></li><li><a href=/r/notes/scratch/goedbloed/ class=navbutton>Goedbloed (2019)</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-c8688d5789736c2ae128963cf705a441 class=toggle>
<label for=section-c8688d5789736c2ae128963cf705a441 class="flex justify-between"><a href=/r/notes/griffiths/ class="navbutton
book-collapse-section">Griffiths Introduction to Electrodynamics</a></label><ul><li><a href=/r/notes/griffiths/ch1-1/ class=navbutton>Vector Algebra</a></li><li><a href=/r/notes/griffiths/ch1-2/ class=navbutton>Differential Calculus</a></li><li><a href=/r/notes/griffiths/ch1-3/ class=navbutton>Integral Calculus</a></li><li><a href=/r/notes/griffiths/ch1-4/ class=navbutton>Curvilinear Coordinates</a></li><li><a href=/r/notes/griffiths/ch1-5/ class=navbutton>The Dirac Delta Function</a></li><li><a href=/r/notes/griffiths/ch1-6/ class=navbutton>The Theory of Vector Fields</a></li><li><a href=/r/notes/griffiths/ch2-1/ class=navbutton>The Electric Field</a></li><li><a href=/r/notes/griffiths/ch2-2/ class=navbutton>Divergence and Curl of Electrostatic Fields</a></li><li><a href=/r/notes/griffiths/ch2-3/ class=navbutton>Electric Potential</a></li><li><a href=/r/notes/griffiths/ch2-4/ class=navbutton>Work and Energy in Electrostatics</a></li><li><a href=/r/notes/griffiths/ch2-5/ class=navbutton>Conductors</a></li><li><a href=/r/notes/griffiths/ch3-1/ class=navbutton>Laplace's Equation</a></li><li><a href=/r/notes/griffiths/ch3-2/ class=navbutton>The Method of Images</a></li><li><a href=/r/notes/griffiths/ch3-3/ class=navbutton>Separation of Variables</a></li><li><a href=/r/notes/griffiths/ch3-4/ class=navbutton>Multipole Expansion</a></li><li><a href=/r/notes/griffiths/ch4-1/ class=navbutton>Polarization</a></li><li><a href=/r/notes/griffiths/ch4-2/ class=navbutton>The Field of a Polarized Object</a></li><li><a href=/r/notes/griffiths/ch4-3/ class=navbutton>The Electric Displacement</a></li><li><a href=/r/notes/griffiths/ch4-4/ class=navbutton>The Linear Dielectrics</a></li><li><a href=/r/notes/griffiths/ch5-1/ class=navbutton>The Lorentz Force Law</a></li><li><a href=/r/notes/griffiths/ch5-2/ class=navbutton>The Biot-Savart Law</a></li><li><a href=/r/notes/griffiths/ch5-3/ class=navbutton>The Divergence and Curl of B</a></li><li><a href=/r/notes/griffiths/ch5-4/ class=navbutton>Magnetic Vector Potential</a></li><li><a href=/r/notes/griffiths/ch6-1/ class=navbutton>Magnetization</a></li><li><a href=/r/notes/griffiths/ch6-2/ class=navbutton>The Field of a Magnetized Object</a></li><li><a href=/r/notes/griffiths/ch6-3/ class=navbutton>The Auxiliary Field H</a></li><li><a href=/r/notes/griffiths/ch6-4/ class=navbutton>Linear and Nonlinear Media</a></li><li><a href=/r/notes/griffiths/ch7-1/ class=navbutton>Electromotive Force</a></li><li><a href=/r/notes/griffiths/ch7-2/ class=navbutton>Electromagnetic Induction</a></li><li><a href=/r/notes/griffiths/ch7-3/ class=navbutton>Maxwell's Equations</a></li><li><a href=/r/notes/griffiths/ch8-0/ class=navbutton>Phys 544 Introduction</a></li><li><a href=/r/notes/griffiths/ch8-1/ class=navbutton>Charge and Energy</a></li><li><a href=/r/notes/griffiths/ch8-2/ class=navbutton>Momentum</a></li><li><a href=/r/notes/griffiths/ch9-1/ class=navbutton>Electromagnetic Waves in One Dimension</a></li><li><a href=/r/notes/griffiths/ch9-2/ class=navbutton>Wave Equation for E and B</a></li><li><a href=/r/notes/griffiths/ch9-3/ class=navbutton>Electromagnetic Waves in Matter</a></li><li><a href=/r/notes/griffiths/ch9-4/ class=navbutton>Electromagnetic Waves in Conductors</a></li><li><a href=/r/notes/griffiths/ch9-5/ class=navbutton>Guided Waves</a></li><li><a href=/r/notes/griffiths/ch10-1/ class=navbutton>Scalar and Vector Potentials</a></li><li><a href=/r/notes/griffiths/ch10-2/ class=navbutton>Retarded Potentials</a></li><li><a href=/r/notes/griffiths/ch10-3/ class=navbutton>Point Charges</a></li><li><a href=/r/notes/griffiths/ch11-1/ class=navbutton>Dipole Radiation</a></li><li><a href=/r/notes/griffiths/problems-ch3/ class=navbutton>Solved Problems Ch3</a></li><li><a href=/r/notes/griffiths/problems-ch5/ class=navbutton>Solved Problems Ch5</a></li><li><a href=/r/notes/griffiths/problems-ch7/ class=navbutton>Solved Problems Ch7</a></li><li><a href=/r/notes/griffiths/problems-ch9/ class=navbutton>Solved Problems Ch9</a></li></ul></li></ul></li></ul><ul class=book-menu-hugo><li><a href=https://github.com/Peppyhare/r target=_blank rel=noopener>Github</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Hugo Themes</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/r/svg/menu.svg class=book-icon alt=Menu></label><h3>WARPXM 201 - Unstructured Geometry</h3><label for=toc-control><img src=/r/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#mesh-loading>Mesh Loading</a><ul><li><a href=#wmdomainsetup><code>WmDomain().setup()</code></a></li><li><a href=#wxmmeshmeshsetup><code>wxm::mesh::mesh.setup()</code></a></li></ul></li><li><a href=#distributed-variables>Distributed Variables</a></li></ul></nav></aside></header><article class="markdown book-article"><link rel=stylesheet href=/r/katex/katex.min.css><script defer src=/r/katex/katex.min.js></script><script defer src=/r/katex/auto-render.min.js onload=loadKatex()></script><script>function loadKatex(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}],throwOnError:!1,trust:e=>["\\htmlId","\\href"].includes(e.command),macros:{"\\lcm":"\\mathop{\\mathrm{lcm}}","\\sen":"\\text{sen}\\,","\\dd":"\\mathop{\\mathrm{d} #1}","\\abs":"\\lvert #1 \\rvert","\\dd":"\\text{d}","\\cross":"\\times","\\pdv":"\\frac{\\partial #1}{\\partial #2}","\\curl":`\\nabla \\cross #1`,"\\vu":"\\mathbf{\\hat{#1}}","\\vdot":"\\dot","\\div":`\\nabla \\cdot #1`,"\\grad":`\\nabla`,"\\dv":"\\frac{d\\,#1}{d\\,#2}","\\gr":"\\gamma","\\vec":"\\mathbf{#1}","\\tagl":"\\tag{#1}","\\eqref":"(#1)","\\laplacian":`\\mathbf{\\nabla ^2}`,"\\label":"{}","\\negadelta":`\\nabla`,"\\eqref":"\\href{###1}{(\\text{#1})}","\\ref":"\\href{###1}{\\text{#1}}","\\label":"\\htmlId{#1}{}"}})}</script><span>\[\]</span><p>Let&rsquo;s try to make sense of the unstructured geometry library that WARPX uses to work with unstructured meshes</p><h1 id=mesh-loading>Mesh Loading
<a class=anchor href=#mesh-loading>#</a></h1><h2 id=wmdomainsetup><code>WmDomain().setup()</code>
<a class=anchor href=#wmdomainsetup>#</a></h2><p>We construct the WmDomain for the sim.</p><script src=/r/mermaid.min.js></script><script>mermaid.initialize({flowchart:{useMaxWidth:!0},theme:"default"})</script><pre class=mermaid>
%%{init: {
  'themeVariables': {
    'fontFamily': 'monospace'
  }
}}%%
classDiagram
    class WmDomain {
	    -WmSolverBase* _parentSolver : Owning WmSolver
	    -int* _primitive_id : Element primitive type, e.g. tets, hexahedrons, triangles
	    -map _patches
	    -map _localPatches
	    -vector _clusterDeviceIndex
	    -vector _clusterDeviceNodeRank
	    -vector _clusterDeviceWeights
    }

</pre><p>First Determine the total number of compute devices in the MPI cluster. Set up <code>_clusterDeviceIndex</code>, <code>_clusterDeviceWeights</code> for the mesh distribution algorithm.</p><p>Then, we get into the mesh setup and leave <code>Wm</code> world for a bit. We&rsquo;ll spend a bunch of time in <code>UC</code> land, but we&rsquo;ll come back.</p><h2 id=wxmmeshmeshsetup><code>wxm::mesh::mesh.setup()</code>
<a class=anchor href=#wxmmeshmeshsetup>#</a></h2><p>Read mesh from the input file, and do <code>wxm::mesh::mesh.setup()</code>. This is where we subclass mesh to arbitrary mesh and split from block mesh impl.</p><ul><li>Makes a new <code>UCDomain</code> and does <code>UCDomain->importFile</code>. <code>UCDomain</code> has a <code>UCElementGroup _domain</code> that does <code>UCElementGroup->importFile</code> to load the mesh file. There are reader functions for ABAQUSFile, HDF5, and GAMBITFile, which should all basically be doing the same thing. Let&rsquo;s go through the ABAQUS parser.</li></ul><pre class=mermaid>
%%{init: {
  'themeVariables': {
    'fontFamily': 'monospace'
  }
}}%%
classDiagram
    class UCElementGroup {
      -std::string _name : Element group name
      -int _index
      -int _partitionIndex
      -bool _virtual
      -int _primitiveID : Primitive type of all elements
      -UCElementGroup* _parent
      -vector~UCElementGroup*~ _children
      -vector~UCElementGroup*~ _virtualChildren
      -vector~UCNodeGroup*~ _nodeGroups : Associated node groups
      -int _numLayers : Number of layers this group is set up for
      -vector~int~ _numElements : # of elements per layer
      -vector~int~ _numNodes : # of nodes per layer
      -vector~UCElement*~ _elements
      -vector~UCNode*~ _nodes
      -UCElement* _nullElement : Non-existent element that represents the exterior of the domain
      -int _meshID
    }
    class UCDomain {
	    -UCElementGroup* _domain : The real domain
    }
</pre><ul><li>Look for NODES block. For each line in the block, the line is <code>&lt;ID>, &lt;xpos>, &lt;ypos>, &lt;zpos></code>. We create a new <code>UCNode</code> with the node ID, the position in each dimension, and we add a <code>nodeGlobalIndex</code> that goes from 0 to total_nodes. Add the node to the UCElementGroup&rsquo;s <code>std::vector&lt;UCNode*> _nodes</code>.</li><li>Look for ELEMENT block. Each element block will be a subdomain containing one or more elements of the same type. For each subdomain, set <code>primitiveID</code> based on the node type (hexahedra &ldquo;C3D8R&rdquo; have <code>primitiveID = 4</code>, tets &ldquo;C3D4&rdquo; have <code>primitiveID = 3</code>, quadrilaterals &ldquo;S4R&rdquo; have <code>primitiveID = 2</code>, &ldquo;STRI3&rdquo; triangles have <code>primitiveID = 1</code>, and lines &ldquo;B21&rdquo; have <code>primitiveID = 0</code>). We create a new subdomain <code>UCElementGroup</code> and add it to the <code>_children</code> list of the parent UCElementGroup. Then we read in each element from the element block. Element definitions are <code>&lt;element ID>, &lt;node1 ID>, &lt;node2 ID>...</code> for however many nodes are in each element.<ul><li>For each element we build up a <code>vector&lt;UCNode*> connectivity</code> list of pointers to the <code>UCNode</code>s in <code>_nodes</code> that define the nodes in the element. Then we create a <code>UCElement</code> with the element ID (mesh&rsquo;s ID for the element), the connectivity list of nodes, the primitiveID (element type), and a globally incrementing <code>elementGlobalIndex</code>. The element contains all of those fields, and we also initialize an empty <code>_neighborhood</code> vector of neighboring elements, and <code>_orientations</code> vector of face normals. We add this element to the <code>_elements</code> vector for this UCElementGroup.</li></ul></li></ul><pre class=mermaid>
%%{init: {
  'themeVariables': {
    'fontFamily': 'monospace'
  }
}}%%
classDiagram
    class UCElement {
      -int _elementID : Element ID as defined in input file
      -int _globalIndex : Global element index
      -int _primitiveID : Type of element
      -vector~UCElement*~ _neighborhood : List of refs to neighboring UCElements
      -vector~UCNode*~ _connectivity : Sorted list of nodes in the element
      -vector~int~ _orientations : For each face, defines the "orientation" of the face w.r.t. its neighboring element
    }
    class UCNode {
      -int _globalIndex : Global index of node in full mesh
      -int _effectiveIndex : Effective global index used for sorting nodes
      -int _id : Node id from input file
      -real _position[3] : Geometric coordinates
      -vector~UCNode*~ _overlapNodes : Periodic boundary mirror node(s)
      -vector~UCNodeGroup*~ _nodeGroups : Node groups this node is assigned to
    }
    class UCLayeredObject {
      -map~UCElementGroup*, int~ _layers: Map of layers
      -map~UCElementGroup*, int~ _indexes: Map of indexes
      -map~UCElementGroup*, bool~ _addedToGroup : Map if object has been added to given group
    }
    UCElement <|-- UCLayeredObject
    UCNode <|-- UCLayeredObject
</pre><ul><li>Then we look for node set groupings defined in a <code>NSET</code> block. Each ABAQUS node set has a string name and a list of node IDs. In our code, we represent the node set as a <code>UCNodeGroup</code>, which is just a list of <code>UCNode</code> pointers along with the group&rsquo;s name.</li></ul><pre class=mermaid>
%%{init: {
  'themeVariables': {
    'fontFamily': 'monospace'
  }
}}%%
classDiagram
    class UCFace {
      -UCElement* _element
      -int _faceIndex : Indicates which face of the element we are. Ordering is standard and defined by the input file
      -vector~int~ _sortedNodes : Effective node indexes making up the face
    }
</pre><ul><li>Finally we call <code>UCElementGroup.interlinkElements()</code><ul><li>Here, we check if periodic boundary conditions were defined. These would be defined as a list of matched name-name pairs describing which <code>UCNodeGroup</code>s should be matched as the same periodic boundary. If so, we go through all of the pairs of matched <code>UCNodeGroup</code>s, sort all of the nodes by position, and add an overlap node to the <code>_overlapNodes</code> list for each appropriate node.</li><li>We make a list of <code>UCFace</code>s for each face of each element. To construct a <code>UCFace</code>, we fill <code>_sortedNodes</code> with the connectivity list for the element, using a pre-defined ordering of nodes as appropriate for the element. For example, for a tetrahedral element, the indices of nodes for each face are &ldquo;faceIndex = [[0,2,1],[0,1,3],[1,2,3],[0,3,2]]&rdquo;. Then we sort the face list so that matching faces are lined up with one another. We iterate through each face in the list. For each one, if the next face in the list has the same set of nodes, then they are overlapping faces and correspond with neighboring elements. We register each element in its neighbor&rsquo;s <code>_neighborhood</code> list for the appropriate face. If there isn&rsquo;t a neighbor, we leave the nullElement in the element&rsquo;s neighborhood for that face index. We also compute the &ldquo;orientation&rdquo; of each face by setting an int value in the corresponding spot in the element&rsquo;s <code>_orientations</code>. I&rsquo;m in agreement with the comments through <code>UCFace.cc</code>, I&rsquo;m not exactly sure what the orientation values mean, but for 2D elements the orientation is 0 or 1 for each &ldquo;face&rdquo;, depending if the lines are parallel or anti-parallel when read from the faces&rsquo; connectivity list. There is a similar, but more complicated calculation for 3D elements that gives 0, 1, or 2 for tetrahedra. It seems to be a way of aligning the nodes for neighboring faces, but the only place I can find that uses the orientation information is <code>WmUnstructuredGeometry::getFaceDistanceBetweenNeighborCentroids()</code>, so we&rsquo;ll probably have to come back to this.</li><li>Now that all of the elements in the UCElementGroup have had their periodic boundary conditions, neighborhood, and orientation set, we are done with the face list, never to be seen again.</li></ul></li><li>Then, we get a chance to apply &ldquo;layers&rdquo; to the domain. According to Sean&rsquo;s dissertation, this is how we group elements that are the same number of steps away from the patch boundary. Elements with layer 0 are on the boundary, and elements with layer -1 are not on the boundary but are neighboring a layer 0 element. This is supposed to define the layout of the element data arrays such that &ldquo;interior&rdquo;, &ldquo;periphery&rdquo;, and &ldquo;external&rdquo; element sets can be stored contiguously and separately to minimize MPI overhead. <code>applyLayers</code> is a monster, so let&rsquo;s step through carefully.<ul><li>We start with a UCElementGroup that has one child domain, so we <code>applyLayers</code> recursively to the children first</li><li>For each element in the group, we run <code>applyLayering()</code> on the element. This iterates over all of the nodes in <code>_connectivity</code> and sets the layer of all nodes to MIN_LAYER, and associates the UCElementGroup with the node. Then, if the element is on the boundary of that group&rsquo;s domain (we test by checking if all the element&rsquo;s neighbors are in the same group), we set its layer to 0 and recursively re-calculate layers for each of its neighbors.</li><li>Once that&rsquo;s done, each element in the group should have group layering information associated. We sort the group&rsquo;s element list by layer, then we assign a monotonically increasing group index to the element&rsquo;s <code>_indexes[&amp;group]</code> and count the number of elements in each layer, storing the result in the group&rsquo;s <code>_numElements</code>. We also do the same thing for the <code>_nodes</code> list, sorting by layer, assigning a group index, and counting by layer into <code>_numNodes[_numLayers + 1 + layer]</code>.</li><li>Once all subdomains have been layered, we call <code>consolidate()</code> on the parent domain. This re-assigns a group index for all of the internal elements to try and create contiguous chunks of elements.</li></ul></li></ul><p>After all that, we&rsquo;ve got a fully initialized UCDomain that contains the entire mesh. Next thing we do is partitioning into patches!</p><ul><li>Start by defining the total number of partitions, based on input parameters and MPI ranks</li><li>For each subdomain, construct adjacency vector by and constructing <code>xadj</code> and <code>adjncy</code> from the list of elements, in the format described in 5.5 of the METIS manual. We don&rsquo;t set any vertex weights or edge weights. Pass that all in to METIS PartGraphRecursive and we get <code>part</code> which is a list of size numElements that tells us which partition each element index should belong to. The patches are each stored as child UCElementGroup subdomains, and we assign each element to one of those groups.</li><li>After partitioning is done, we go back through the <code>applyLayers()</code> process all over again for each subdomain to assign layers to the re-distributed elements. Yowch.</li></ul><p>Back in mesh set-up, we convert our <code>UCElementGroup</code>s to <code>WmUnstructuredPatch</code>es, and add them to the <code>WmDomain</code>.</p><pre class=mermaid>
%%{init: {
  'themeVariables': {
    'fontFamily': 'monospace'
  }
}}%%
classDiagram
    class WmUnstructuredPatch {
      -string _name
      -int _patchIndex
      -string _subdomainName
      -int _primitiveID
      -WmDomain* _domain : Parent domain
      -bool _local
      -int _procID
      -int _numLayers
      -int* _numElementsPerLayer
      -int __numTotalElements
      -int _meshID
      -int _pMeshID
      -int* _meshTranslation : Mapping of patch element indexes to "global" mesh indexes
      -int* _numNodesPerLayer : Total nodes in each layer
      -int _numTotalNodes
      -WmUnstructuredGeometry* _pUG
      -map~int, WmUnstructuredPatchLink*~ _linkedPatches : Linked patches, indexed by 'from' group index
      -WxRange _patchRange : Range of patch within subdomain
      -WxRange _subdomainRange : Range of subdomain
    }
</pre><ul><li>For each <code>WmUnstructuredPatch</code>, we start by constructing a <code>UCElementGroupLinkSet</code> of links from its neighboring <code>UCElementGroup</code>s to itself. The resulting set of links describe the interfaces between element group for this patch and the <code>UCElementGroup</code>s that are its neighbors. Continuing the conversion process, we convert those links to <code>WmUnstructuredPatchLink</code>s and add them to the <code>_linkedPatches</code> in our patch.</li></ul><pre class=mermaid>
%%{init: {
  'themeVariables': {
    'fontFamily': 'monospace'
  }
}}%%
classDiagram
    class UCElementGroupLink {
      -UCElementGroup& _fromGroup : Group in which element is 'internal'
      -UCElementGroup& _toGroup : Group in which element is 'external'
      -vector~UCElement*~ _elements : Elements constituting the link
      -int _numIndexes
      -vector~int~ _fromIndexes : Indexes of elements in fromGroup
      -vector~int~ _toIndexes : Indexes of elements in toGroup
      -vector~int~ _numElementsPerLayer : Number of elements in each layer of link
  }
</pre><pre class=mermaid>
%%{init: {
  'themeVariables': {
    'fontFamily': 'monospace'
  }
}}%%
classDiagram
    class WmUnstructuredPatchLink {
      -WmUnstructuredPatch& _to_patch
      -WmUnstructuredPatch* _from_patch
      -bool _sharedBoundary : Whether the link is between two neighboring patches in the same domain
      -string _from_patch_name
      -int _from_patch_index : Index of the 'from' patch
      -vector~int~ _numElementsPerLayer : Number of elements in each element layer
      -int _numElements : Number of elements in the link
      -vector~int~ _from_indexes : Element indexes in the 'from' patch to pull from
      -vector~int~ _to_indexes : Element indexes in the 'to' patch to push to
  }
</pre><ul><li>We then set the patch range by creating two one-dimensional <code>WxRange</code>s. The first is the <code>_patchRange</code> which contains the range of absolute element indexes in the patch&rsquo;s parent domain (e.g. [0..12345] for one patch, then [12346..54321] for another). The <code>_subdomainRange</code> contains the entire parent domain&rsquo;s range (e.g. [0..54321]).</li></ul><pre class=mermaid>
%%{init: {
  'themeVariables': {
    'fontFamily': 'monospace'
  }
}}%%
classDiagram
    class WxRange {
    }
    class WxBox~int~ {
      -int _ndims : Number of dimensions this box spans
      -int[8] _lower : Lower index in each dimension
      -int[8] _upper : Upper index in each dimension
      -int[8] _length : [upper - lower]
    }
    WxBox~int~ <|-- WxRange
</pre><ul><li>Next we add index information to the <code>WmUnstructuredPatchLink</code>s by copying the index arrays from the corresponding <code>UCElementGroupLink</code>s. These are the element index mappings between the two patch/groups.</li></ul><pre class=mermaid>
%%{init: {
  'themeVariables': {
    'fontFamily': 'monospace'
  }
}}%%
classDiagram
    class WmUnstructuredGeometry {
      -WmUnstructuredPatch& _patch
      -string _primitive
      -int _primitiveID
      -int _numElements
      -int _numNodes
      -int* _connectivity : [_numElementx X _numNodesPerElement]
      -int* _neighborhood : [_numElements X _numFacesPerElement]
      -int* _orientations : [_numElements X _numFacesPerElement]
      -real* _coordinates : Node/vertex positions
      -real* _transformCoordinates
      -real* _centroids : Position of element centroids
      -real* _norms : Face normal vectors
      -real* _volumes : Element volumes
      -real* _areas : Face areas
      -map~string, vector[int]~ _nodeGroups : Named groups of nodes defined for boundary conditions
      -int _num_boundary_faces : # of faces with neighbor = -1
      -int _numDimsPerNode : # Dimensions used to store nodes/vertices
      -int _numDimsPerPrimitive
      -int _numTransformCoordinates
      -int _numNodesPerElement : # Physical nodes unrelated to DG order
      -int _numFacesPerElement
      -int _numNodesPerFace
    }
</pre><ul><li>Now we get to the fun stuff: Generating a full <code>WmUnstructuredGeometry</code> for each local patch. By &rsquo;local&rsquo; we mean patches that are assigned to the local compute device.<ul><li>We can get <code>_coordinates</code>, <code>_connectivity</code>, <code>_neighborhood</code>, and <code>_orientations</code> just by iterating over the structures in <code>UCElementGroup</code> and constructing some new contiguous arrays with the right values. For neighborhood, instead of pointers to elements or <code>_nullElement</code> we just fill with the element&rsquo;s group index or -1 for null neighbors.</li><li>To get the rest, we rely on the various <code>generateEG</code> (generate element geometry) and <code>generateCentroid</code> functions defined for each element type in wmunstructuredgeometry.cc. For each element:<ul><li><code>nodePositions</code> is the list of <code>[x1, y1, z1, x2, y2, z2, ...]</code> node locations for each element, with nodes in order of the connectivity array for the element.</li><li>transformed coordinates <code>tC</code> are the coefficients \( \Gamma \) of the affine transformation from the isoparametric space (e.g. where the tetrahedron is defined by the coordinates [0, 0], [0, 1], [1, 0], [1, 1]) to the coordinate space such that \( x = \Gamma_0 + \Gamma_1 \xi_0 + \Gamma_2 \xi_1 + \Gamma_3 \xi_2 \). These are the elements of the coveted coordinate transform Jacobian matrix.</li><li>We compute the centroid coordinates and add them at <code>_centroids[3 * elementIndex]</code></li><li>We do some math to fill in the parts of <code>_norms</code>, <code>_volumes</code>, and <code>_areas</code> associated with the element.</li><li>To finish up, we iterate over the <code>_neighborhood</code> to check for boundary faces (-1&rsquo;s), and tally them up in <code>_num_boundary_faces</code></li></ul></li></ul></li><li>If there are multiple patches in a subdomain, we may need the global element indexes to apply initial conditions that may have been generated for the mesh before partitioning. So we search up through the parent domain, compute an index offset based on the number of elements in each sibling patch, and add that offset to our element indexes to get a <code>_meshTranslation</code> that gives the &ldquo;global&rdquo; index for each element.</li><li>For boundary condition definition, we need to group together all of the nodes that are defined on a node set in the mesh (see NSET above). We just plop the sorted node indexes from each <code>UCNodeGroup</code> right into the <code>_nodeGroups</code> map for our patch&rsquo;s WmUnstructuredGeometry.</li></ul><p>At this point, the mesh geometry structure is fully initialized. On rank 0, we write out the top-level <code>UCDomain</code> to disk in hdf5 format using <code>UCElementGroup::write</code>.</p><pre class=mermaid>
%%{init: {
  'themeVariables': {
    'fontFamily': 'monospace'
  }
}}%%
classDiagram
    class WmBasisArraySet {
      -int _two_num_flux_arrays_flag
      -int _numFacesPerElement
      -int _numFacesPerElementSquares
      -int _numFaceNodes
      -int _numFaceNodesSquares
      -int _numTotalFaceNodes
      -int _numTotalFaceNodesDeduplicated
      -int _numInternalNodes
      -int _numTotalNodes
      -int _numGaussQuadNodes
      -int _numDims : Actual dimensionality of elements
      -int _numDimsUnstruct : Number of unstructured dimensions
      -int _numOrientations
      -int _spatialOrder
      -int _numInteriorPositivityPreservingQuadNodes
      -real _vol_multiplier
      -int _numSubElements
      -int _numNodesPerSubElement
      -vector~int~ _subElementConnectivity
      -int _basisArray_NumericalFlux_Size
      -int _basisArray_NumericalFlux_altFace_Size
      -int _basisArray_InternalFlux_Size
      -int _basisArray_LinearAverage_Size
      -int _basisArray_LinearCenter_Size
      -int _basisArray_MonomialConversion_Size
      -int _basisArray_Derivative_Approximation_Size
      -real _cfl
      -int _num_face_types : Used for e.g. phase space mixed elements
      -vector~int~ _num_faces_per_face_type
      -vector~int~ _num_face_nodes_per_face_type
      -vector~int~ _num_face_nodes_per_face
      -vector~int~ _faceNodesDeduplicated
      -vector~real~ _nodePositionsGaussQuad
      -vector~real~ _basisArray_GaussQuad
      -vector~real~ _basisArray_LagrangeOnGQnodes
      -vector~real~ _nodePositions
      -vector~real~ _basisArray_NumericalFlux
      -vector~real~ _basisArray_NumericalFlux_altFace : Alternate num. flux for velocity space
      -vector~real~ _basisArray_InternalFlux
      -vector~real~ _basisArray_LinearAverage
      -vector~real~ _basisArray_LinearCenter
      -vector~real~ _basisArray_MonomialConversion
      -vector~real~ _basisArray_OrthogonalToCollocation
      -vector~real~ _basisArray_CollocationToOrthogonal
      -vector~function[real(const array[real], 3]&)~ _monomial_functions
      -vector~real~ _basisArray_Derivative_Approximation
      -vector~real~ _basisArray_faceQuadratureWeights
      -vector~real~ _basisArray_evaluateAtInteriorPositivityPreservingQuadNodes
      -vector~vector[int]~ _orientations
      -vector~vector[int]~ _faceNodes
      -bool _has_csr
      -vector~int~ _ups2csr_val_lengths
      -vector~vector[real]~ _ups2csr_val
      -vector~vector[int]~ _ups2csr_col
      -vector~vector[int]~ _ups2csr_rowptr
      -vector~int~ _Drcsr_val_lengths
      -vector~vector[real]~ _Drcsr_val
      -vector~vector[int]~ _Drcsr_col
      -vector~vector[int]~ _Drcsr_rowptr
      -vector~int~ _ups1csr_val_lengths
      -vector~vector[real]~ _ups1csr_val
      -vector~vector[int]~ _ups1csr_col
      -vector~vector[int]~ _ups1csr_rowptr

    }
</pre><p>If the input file specifies that it wants a nodal mesh to be written out as well, then we compute the basis arrays for
the dimension and nodal order specified in the input file.</p><ul><li>Lucky for us, at this point we&rsquo;re just reading out the pre-computed values stored in the appropriate <code>src/basis/nodal_basis/*.txt</code> file.</li><li>In <code>UCElementGroup::exportBasisDecomposition()</code> constructs the sub-elements and sub-coordinates of the basis nodes on each element for export. The fields we end up with in the hdf5 output are <code>patchIndexes</code>, <code>subElementConnectivity</code>, <code>patchNames</code>, <code>startingElementIndexes</code>, <code>startingSubElementIndexes</code>, <code>coordinates</code>, <code>connectivity</code>, and <code>element_connectivity</code>.</li><li>Write out the <code>plotMesh</code> hdf5 file containing all of the basis node locations and connectivity arrays, to make post-processing easier.</li></ul><p>Finally we write out a restart mesh in hdf5 format using <code>UCElementGroup::exportWithoutBasisDecomposition</code>. This works similarly to the basis export, but it only contains <code>coordinates</code> and <code>connectivity</code>. This generates the <code>restartMesh*.h5</code> files in the meshes/ directory.</p><h1 id=distributed-variables>Distributed Variables
<a class=anchor href=#distributed-variables>#</a></h1><p>Now we&rsquo;ve got a working <code>WmDomain</code>, we iterate through the <code>variable_t</code>s from the input file and call <code>setup()</code> to initialize it.</p><pre class=mermaid>
%%{init: {
  'themeVariables': {
    'fontFamily': 'monospace'
  }
}}%%
classDiagram
    class wxm::variable::variable_t {
      -vector~string~ _component_names : List of component names in order
      -WmSolverBase* _p_parent
      -bool _is_setup
    }
    class wxm::variable::distributed_variable_t {
      -vector~string~ _subdomain_names
      -vector~string~ _virtual_subdomains
    }
    class wxm::dfem::variable::UniqueDistributedVariable {
      -vector~string~ _subdomain_names
      -vector~string~ _virtual_subdomains
      -vector~UniqueDistributedComponent*~ _component_arrays : Where the data is stored
      -WxRange _element_range : Range of each element
    }
</pre></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/Peppyhare/r/commit/be599c09e769791428b4bb79713d4790c0493685 title='Last modified by Evan Bluhm | August 29, 2025' target=_blank rel=noopener><img src=/r/svg/calendar.svg class=book-icon alt>
<span>August 29, 2025</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#mesh-loading>Mesh Loading</a><ul><li><a href=#wmdomainsetup><code>WmDomain().setup()</code></a></li><li><a href=#wxmmeshmeshsetup><code>wxm::mesh::mesh.setup()</code></a></li></ul></li><li><a href=#distributed-variables>Distributed Variables</a></li></ul></nav></div></aside></main></body></html>